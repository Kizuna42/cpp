/*
 * ====================================================================
 * CPP02 ex01: 型変換コンストラクタ - Fixed クラスヘッダー解説版
 * ====================================================================
 * 
 * この演習では、Fixedクラスを実用的なレベルに拡張します。
 * - int/float からの変換コンストラクタ
 * - float/int への変換メソッド
 * - ストリーム出力演算子のオーバーロード
 * 
 * これらによって、固定小数点数を自然に使えるようになります。
 */

#ifndef FIXED_HPP
#define FIXED_HPP

#include <iostream>
#include <cmath>

/*
 * ====================================================================
 * includeの分析
 * ====================================================================
 * 
 * #include <cmath>
 * 
 * なぜ必要？
 * - float から int への変換で roundf() 使用
 * - 数学的な丸め処理の実装
 * - C++98での標準的な数学ライブラリ
 * 
 * 代替案:
 * - <math.h> (C言語版) も使用可能
 * - しかし <cmath> がC++では推奨
 */

/*
 * ====================================================================
 * Fixed クラス - 実用的な固定小数点数実装
 * ====================================================================
 * 
 * 【ex00からの進歩】
 * ex00: OCFの基本実装のみ
 * ex01: 実用的な型変換とI/O機能を追加
 * 
 * 【新機能】
 * 1. int/float からの変換コンストラクタ
 * 2. int/float への変換メソッド
 * 3. ストリーム出力演算子
 * 
 * 【設計哲学】
 * C++の組み込み型と同じような使い心地を実現
 * Fixed f = 42;     // int から変換
 * Fixed g = 3.14f;  // float から変換
 * std::cout << f;   // 直接出力可能
 */
class Fixed {
private:
    /*
     * プライベートメンバは ex00 と同じ
     * 内部表現は変更せず、インターフェースのみ拡張
     * これがカプセル化の利点
     */
    int _value;
    static const int _fractionalBits = 8;

public:
    /*
     * ====================================================================
     * OCF要素（ex00と同じ）
     * ====================================================================
     */
    
    /*
     * Fixed(void);
     * デフォルトコンストラクタ（ex00と同じ）
     * 
     * 重要: 他のコンストラクタを追加しても
     * デフォルトコンストラクタは必要
     * - 配列作成: Fixed arr[10];
     * - メンバ変数としての使用
     */
    Fixed(void);
    
    /*
     * ====================================================================
     * 新機能1: 型変換コンストラクタ
     * ====================================================================
     */
    
    /*
     * Fixed(const int value);
     * 
     * 【役割】
     * 整数から固定小数点数への変換
     * Fixed f = 42; または Fixed f(42);
     * 
     * 【変換ロジック】
     * 内部表現 = value << _fractionalBits
     * 例: 42 → 42 * 256 = 10752
     * 
     * なぜ左シフト？
     * - 効率的な2のべき乗との乗算
     * - value * (2^8) = value << 8
     * - 浮動小数点演算不要
     * 
     * 【なぜ const int？】
     * - 関数内でパラメータを変更しない
     * - 型安全性の向上
     * - 一時オブジェクトからの変換可能
     */
    Fixed(const int value);
    
    /*
     * Fixed(const float value);
     * 
     * 【役割】
     * 浮動小数点数から固定小数点数への変換
     * Fixed f = 3.14f; または Fixed f(3.14f);
     * 
     * 【変換ロジック】
     * 内部表現 = roundf(value * (2^_fractionalBits))
     * 例: 3.14f → roundf(3.14 * 256) = roundf(803.84) = 804
     * 
     * なぜ roundf() が必要？
     * - 浮動小数点の精度誤差対応
     * - 最も近い整数への丸め
     * - 一貫した変換結果
     * 
     * 【精度の考慮】
     * _fractionalBits = 8 の場合
     * 最小単位: 1/256 ≈ 0.00390625
     * より細かい値は丸められる
     */
    Fixed(const float value);
    
    /*
     * コピーコンストラクタと代入演算子（ex00と同じ）
     * 内部表現が変わらないので実装も同じ
     */
    Fixed(const Fixed& other);
    Fixed& operator=(const Fixed& other);
    
    /*
     * デストラクタ（ex00と同じ）
     */
    ~Fixed(void);
    
    /*
     * ====================================================================
     * アクセサメソッド（ex00と同じ）
     * ====================================================================
     */
    int getRawBits(void) const;
    void setRawBits(int const raw);
    
    /*
     * ====================================================================
     * 新機能2: 型変換メソッド
     * ====================================================================
     */
    
    /*
     * float toFloat(void) const;
     * 
     * 【役割】
     * 固定小数点数から浮動小数点数への変換
     * 
     * 【変換ロジック】
     * 浮動小数点値 = (float)_value / (2^_fractionalBits)
     * 例: _value = 804 → 804.0f / 256.0f = 3.140625f
     * 
     * 【なぜキャストが必要？】
     * (float)_value
     * - 整数除算を防ぐ
     * - 804 / 256 = 3 (整数除算)
     * - 804.0f / 256.0f = 3.140625f (浮動小数点除算)
     * 
     * 【const correctness】
     * const修飾でオブジェクトの変更なしを保証
     */
    float toFloat(void) const;
    
    /*
     * int toInt(void) const;
     * 
     * 【役割】
     * 固定小数点数から整数への変換（小数部切り捨て）
     * 
     * 【変換ロジック】
     * 整数値 = _value >> _fractionalBits
     * 例: _value = 804 → 804 >> 8 = 3
     * 
     * なぜ右シフト？
     * - 効率的な2のべき乗での除算
     * - _value / (2^8) = _value >> 8
     * - 小数部の自動切り捨て
     * 
     * 【負数の考慮】
     * C++の右シフトは算術シフト
     * 負数でも正しく動作する
     */
    int toInt(void) const;
};

/*
 * ====================================================================
 * 新機能3: ストリーム出力演算子のオーバーロード
 * ====================================================================
 * 
 * std::ostream& operator<<(std::ostream& out, const Fixed& fixed);
 * 
 * 【役割】
 * std::cout << fixed; で直接出力を可能にする
 * 
 * 【なぜクラス外で定義？】
 * - 左オペランドが std::ostream
 * - メンバ関数では実現不可能
 * - フリー関数として実装が必要
 * 
 * 【パラメータ解析】
 * std::ostream& out:
 * - 出力ストリーム（cout, ofstream等）
 * - 参照渡しで効率化
 * - 戻り値として返してストリーム連鎖可能
 * 
 * const Fixed& fixed:
 * - 出力対象のFixedオブジェクト
 * - const参照で効率的かつ安全
 * 
 * 【戻り値】
 * std::ostream& を返すことで連鎖可能
 * std::cout << f1 << " " << f2 << std::endl;
 * 
 * 【実装方針】
 * out << fixed.toFloat(); 
 * 浮動小数点表現で出力（人間に読みやすい）
 */
std::ostream& operator<<(std::ostream& out, const Fixed& fixed);

/*
 * ====================================================================
 * 学習のポイント
 * ====================================================================
 * 
 * 【このヘッダーから学ぶべきこと】
 * 
 * 1. 型変換コンストラクタの設計
 *    - 暗黙的変換の提供
 *    - 効率的な変換アルゴリズム
 * 
 * 2. ビット演算の活用
 *    - 左シフト（<<）による高速乗算
 *    - 右シフト（>>）による高速除算
 * 
 * 3. 演算子オーバーロードの基本
 *    - メンバ vs フリー関数の選択
 *    - ストリーム連鎖の実現
 * 
 * 4. 精度とパフォーマンスのバランス
 *    - 固定小数点の特性理解
 *    - 丸め誤差の考慮
 * 
 * 【次のステップ】
 * - TUTORIAL_Fixed.cpp で実装詳細を学習
 * - TUTORIAL_main.cpp で使用例を確認
 * - ex02 で完全な演算子オーバーロードを学習
 */

#endif

/*
 * ====================================================================
 * 使用例の予習
 * ====================================================================
 * 
 * このヘッダーにより可能になる自然な使用法:
 * 
 * Fixed a;           // デフォルト構築 (0.0)
 * Fixed b(10);       // int からの変換 (10.0)
 * Fixed c(42.42f);   // float からの変換 (42.42)
 * Fixed d(b);        // コピー構築
 * 
 * std::cout << a << std::endl;   // 直接出力: 0
 * std::cout << b << std::endl;   // 直接出力: 10
 * std::cout << c << std::endl;   // 直接出力: 42.4219 (近似値)
 * 
 * int i = c.toInt();       // 42
 * float f = c.toFloat();   // 42.4219f (近似値)
 * 
 * 固定小数点数がより使いやすくなる！
 */

/*
 * ====================================================================
 * 設計判断の解説
 * ====================================================================
 * 
 * 【なぜ explicit でないコンストラクタ？】
 * 
 * explicit Fixed(const int value);  // 明示的変換のみ
 * vs
 * Fixed(const int value);           // 暗黙的変換も可能
 * 
 * 採用: 暗黙的変換可能
 * 理由: Fixed = 42; のような自然な記述を可能にする
 * 
 * 【トレードオフ】
 * 利点: 使いやすさ、組み込み型に近い感覚
 * 欠点: 意図しない変換の可能性
 * 
 * 【プロの判断】
 * 数値型では暗黙的変換が一般的
 * リソース管理クラスでは explicit が安全
 */