/*
 * ====================================================================
 * CPP02 ex02: Now we're talking - main関数解説版
 * ====================================================================
 * 
 * 【学習目標】
 * - 算術演算子オーバーロードの実践使用
 * - 比較演算子オーバーロードの動作確認
 * - インクリメント/デクリメント演算子の理解
 * - static関数（min/max）の使用方法
 * - 演算子の優先順位と結合則の体験
 * - Fixed型での完全な数値計算システム
 * 
 * 【重要概念】
 * - 演算子オーバーロードによる自然な数値型の実現
 * - C++の式評価順序と一時オブジェクト
 * - 前置/後置インクリメントの違い
 * - static関数によるユーティリティ機能
 */

#include "Fixed.hpp"

/*
 * ====================================================================
 * main関数解説
 * ====================================================================
 */
int main(void) {
    /*
     * 【プログラムの目的】
     * 
     * この演習では、Fixed クラスが完全な数値型として機能することを実証：
     * 1. 基本的な算術演算（+, -, *, /）
     * 2. 比較演算（>, <, ==, !=, >=, <=）
     * 3. インクリメント/デクリメント（++, --）
     * 4. 静的関数によるmin/max計算
     * 5. 複雑な式での演算子連鎖
     * 
     * 【学習のポイント】
     * - 各演算子が内部でどのように実装されているか
     * - 演算結果の精度と固定小数点特有の制約
     * - C++の型システムとの完全な統合
     */
    
    /*
     * ====================================================================
     * セクション1: 基本オブジェクトの作成
     * ====================================================================
     */
    
    /*
     * 【デフォルト構築】
     * Fixed a;
     * 
     * 内部動作：
     * - デフォルトコンストラクタ呼び出し
     * - _fixedPointValue = 0
     * - 値は 0.0 を表現
     * - ログ出力: "Default constructor called"
     */
    Fixed a;
    
    /*
     * 【複雑な式での初期化】
     * Fixed const b(Fixed(5.05f) * Fixed(2));
     * 
     * この行の詳細分解：
     * 
     * 1. Fixed(5.05f) 一時オブジェクト作成
     *    - Float constructor called
     *    - 5.05f → 固定小数点変換
     * 
     * 2. Fixed(2) 一時オブジェクト作成
     *    - Int constructor called
     *    - 2 → 固定小数点変換
     * 
     * 3. operator* 呼び出し
     *    - 乗算演算子オーバーロード実行
     *    - 結果: 5.05 * 2 = 10.1（近似値）
     *    - 新しい Fixed 一時オブジェクト作成
     * 
     * 4. Copy constructor でb初期化
     *    - 計算結果がbにコピー
     *    - Copy constructor called
     * 
     * 5. 一時オブジェクト達の破棄
     *    - 3つの一時オブジェクトのDestructor called
     * 
     * 【重要な観察点】
     * - 演算子オーバーロードの自然な使用感
     * - 複数の一時オブジェクトの生成と破棄
     * - const指定による b の不変性保証
     */
    Fixed const b(Fixed(5.05f) * Fixed(2));
    
    /*
     * ====================================================================
     * セクション2: 基本出力とインクリメント演算
     * ====================================================================
     */
    
    /*
     * 【現在の a の値出力】
     * std::cout << a << std::endl;
     * 
     * 期待出力: "0"
     * - a はデフォルト構築されているので 0.0
     * - operator<< による自然な出力
     */
    std::cout << a << std::endl;
    
    /*
     * 【前置インクリメント】
     * std::cout << ++a << std::endl;
     * 
     * 内部動作：
     * 1. operator++() (前置版) 呼び出し
     * 2. a の内部値を1増加（_fixedPointValue += 256）
     * 3. a 自身の参照を返す
     * 4. 変更後の a が出力される
     * 
     * 期待出力: "1"
     * 
     * 【前置インクリメントの特徴】
     * - 値を変更してから結果を返す
     * - 戻り値は参照（&）
     * - 一時オブジェクトを作らない（効率的）
     */
    std::cout << ++a << std::endl;
    
    /*
     * 【インクリメント後の a の確認】
     * std::cout << a << std::endl;
     * 
     * 期待出力: "1"
     * - 前置インクリメントにより a は 1.0 になっている
     * - 値の変更が永続的であることを確認
     */
    std::cout << a << std::endl;
    
    /*
     * 【後置インクリメント】
     * std::cout << a++ << std::endl;
     * 
     * 内部動作：
     * 1. operator++(int) (後置版) 呼び出し
     * 2. 現在の a のコピーを作成（戻り値用）
     * 3. a の内部値を1増加
     * 4. 変更前の値（コピー）を返す
     * 5. 変更前の値が出力される
     * 
     * 期待出力: "1"（変更前の値）
     * 
     * 【後置インクリメントの特徴】
     * - 現在の値を返してから変更
     * - 戻り値はコピー
     * - 一時オブジェクトを作る（非効率）
     */
    std::cout << a++ << std::endl;
    
    /*
     * 【インクリメント後の a の確認】
     * std::cout << a << std::endl;
     * 
     * 期待出力: "2"
     * - 後置インクリメントにより a は 2.0 になっている
     * - 出力は変更前だが、値は確実に変更されている
     */
    std::cout << a << std::endl;
    
    /*
     * ====================================================================
     * セクション3: 複雑な演算結果の確認
     * ====================================================================
     */
    
    /*
     * 【乗算結果の確認】
     * std::cout << b << std::endl;
     * 
     * 期待出力: "10.1"（近似値）
     * - b は Fixed(5.05f) * Fixed(2) の結果
     * - 固定小数点演算の精度制限により近似値
     * - 実際は 10.099609375 (2585/256) 程度
     */
    std::cout << b << std::endl;
    
    /*
     * 【静的関数 max の使用】
     * std::cout << Fixed::max(a, b) << std::endl;
     * 
     * 内部動作：
     * 1. Fixed::max(const Fixed&, const Fixed&) 呼び出し
     * 2. a (2.0) と b (10.1) を比較
     * 3. より大きい値（b）の参照を返す
     * 4. b の値が出力される
     * 
     * 期待出力: "10.1"（近似値）
     * 
     * 【静的関数の利点】
     * - オブジェクトインスタンスが不要
     * - ユーティリティ関数として機能
     * - クラス名::関数名 での呼び出し
     */
    std::cout << Fixed::max(a, b) << std::endl;
    
    /*
     * ====================================================================
     * セクション4: 追加テスト - 四則演算の確認
     * ====================================================================
     */
    
    std::cout << "\n=== Additional Tests ===" << std::endl;
    
    /*
     * 【新しいテスト オブジェクト作成】
     */
    Fixed c(10);      // 整数からの変換: 10.0
    Fixed d(3.5f);    // 浮動小数点からの変換: 3.5（近似値）
    
    /*
     * 【基本値の表示】
     */
    std::cout << "c = " << c << ", d = " << d << std::endl;
    // 期待出力: "c = 10, d = 3.5"
    
    /*
     * 【加算演算子のテスト】
     * c + d
     * 
     * 内部動作：
     * 1. operator+(const Fixed&, const Fixed&) 呼び出し
     * 2. 内部値の加算: c._value + d._value
     * 3. 新しい Fixed オブジェクトで結果を返す
     * 
     * 計算: 10.0 + 3.5 = 13.5
     */
    std::cout << "c + d = " << c + d << std::endl;
    
    /*
     * 【減算演算子のテスト】
     * c - d
     * 
     * 計算: 10.0 - 3.5 = 6.5
     */
    std::cout << "c - d = " << c - d << std::endl;
    
    /*
     * 【乗算演算子のテスト】
     * c * d
     * 
     * 内部動作（固定小数点乗算）：
     * 1. (c._value * d._value) を計算
     * 2. 結果を適切なスケールに調整
     * 3. オーバーフローの可能性に注意
     * 
     * 計算: 10.0 * 3.5 = 35.0
     */
    std::cout << "c * d = " << c * d << std::endl;
    
    /*
     * 【除算演算子のテスト】
     * c / d
     * 
     * 内部動作（固定小数点除算）：
     * 1. スケール調整してから除算実行
     * 2. ゼロ除算チェック（実装依存）
     * 3. 精度制限による近似値
     * 
     * 計算: 10.0 / 3.5 ≈ 2.857...
     * 固定小数点では: 2.85546875 (731/256) 程度
     */
    std::cout << "c / d = " << c / d << std::endl;
    
    /*
     * ====================================================================
     * セクション5: 比較演算子のテスト
     * ====================================================================
     */
    
    /*
     * 【大なり比較】
     * c > d
     * 
     * 内部動作：
     * 1. operator>(const Fixed&, const Fixed&) 呼び出し
     * 2. 内部値の比較: c._value > d._value
     * 3. bool 値を返す
     * 
     * 比較: 10.0 > 3.5 → true
     */
    std::cout << "c > d: " << (c > d) << std::endl;
    
    /*
     * 【小なり比較】
     * c < d
     * 
     * 比較: 10.0 < 3.5 → false
     */
    std::cout << "c < d: " << (c < d) << std::endl;
    
    /*
     * 【等価比較】
     * c == d
     * 
     * 内部動作：
     * - 内部値の完全一致をチェック
     * - 浮動小数点とは異なり、固定小数点では厳密比較可能
     * 
     * 比較: 10.0 == 3.5 → false
     */
    std::cout << "c == d: " << (c == d) << std::endl;
    
    /*
     * ====================================================================
     * セクション6: 静的 min/max 関数のテスト
     * ====================================================================
     */
    
    /*
     * 【静的 min 関数】
     * Fixed::min(c, d)
     * 
     * 比較: min(10.0, 3.5) → 3.5
     */
    std::cout << "min(c, d) = " << Fixed::min(c, d) << std::endl;
    
    /*
     * 【静的 max 関数】
     * Fixed::max(c, d)
     * 
     * 比較: max(10.0, 3.5) → 10.0
     */
    std::cout << "max(c, d) = " << Fixed::max(c, d) << std::endl;
    
    /*
     * ====================================================================
     * プログラム終了処理
     * ====================================================================
     */
    return 0;
    
    /*
     * オブジェクト破棄順序（逆順）：
     * 1. d のデストラクタ
     * 2. c のデストラクタ
     * 3. b のデストラクタ
     * 4. a のデストラクタ
     * 
     * さらに、演算過程で作られた一時オブジェクトも破棄される
     */
}

/*
 * ====================================================================
 * 期待される出力例
 * ====================================================================
 * 
 * プログラム実行時の予想出力：
 * 
 * // コンストラクタ/デストラクタのログ（実装依存）
 * Default constructor called           ← Fixed a;
 * Float constructor called            ← Fixed(5.05f)
 * Int constructor called              ← Fixed(2)
 * ... (演算子による一時オブジェクト処理)
 * Copy constructor called             ← const b の初期化
 * ... (一時オブジェクトの破棄)
 * 
 * // メインの出力
 * 0                                   ← std::cout << a
 * 1                                   ← std::cout << ++a
 * 1                                   ← std::cout << a
 * 1                                   ← std::cout << a++（変更前の値）
 * 2                                   ← std::cout << a（変更後の値）
 * 10.1                               ← std::cout << b（近似値）
 * 10.1                               ← Fixed::max(a, b)
 * 
 * === Additional Tests ===
 * c = 10, d = 3.5
 * c + d = 13.5
 * c - d = 6.5
 * c * d = 35
 * c / d = 2.85547                    ← 近似値
 * c > d: 1                           ← true
 * c < d: 0                           ← false
 * c == d: 0                          ← false
 * min(c, d) = 3.5
 * max(c, d) = 10
 * 
 * // 最後にデストラクタログ
 * Destructor called                   ← d
 * Destructor called                   ← c
 * Destructor called                   ← b
 * Destructor called                   ← a
 */

/*
 * ====================================================================
 * 学習確認チェックリスト
 * ====================================================================
 * 
 * この main 関数で確認すべき項目：
 * 
 * □ 四則演算子（+, -, *, /）の動作
 * □ 比較演算子（>, <, ==等）の動作
 * □ 前置インクリメント（++var）の動作
 * □ 後置インクリメント（var++）の動作
 * □ 前置/後置インクリメントの違い
 * □ 静的関数（min, max）の使用方法
 * □ 複雑な式での演算子連鎖
 * □ 一時オブジェクトの生成と破棄
 * □ 固定小数点演算の精度制限
 * □ const correctness の実践
 * 
 * 【実習課題】
 * 1. より複雑な数式での演算精度確認
 * 2. 演算子の優先順位を意識した式の作成
 * 3. オーバーフローが起きる計算の実験
 * 4. 前置/後置インクリメントのパフォーマンス比較
 * 5. 0による除算のエラーハンドリング確認
 */

/*
 * ====================================================================
 * 演算子オーバーロード設計の考察
 * ====================================================================
 * 
 * 【算術演算子の実装パターン】
 * 
 * 基本的な実装戦略：
 * ```cpp
 * Fixed operator+(const Fixed& lhs, const Fixed& rhs) {
 *     return Fixed(lhs.toFloat() + rhs.toFloat());
 * }
 * ```
 * 
 * より効率的な実装：
 * ```cpp
 * Fixed operator+(const Fixed& lhs, const Fixed& rhs) {
 *     Fixed result;
 *     result.setRawBits(lhs.getRawBits() + rhs.getRawBits());
 *     return result;
 * }
 * ```
 * 
 * 【比較演算子の実装パターン】
 * 
 * 基本実装：
 * ```cpp
 * bool operator>(const Fixed& lhs, const Fixed& rhs) {
 *     return lhs.getRawBits() > rhs.getRawBits();
 * }
 * ```
 * 
 * 【インクリメント演算子の実装パターン】
 * 
 * 前置インクリメント：
 * ```cpp
 * Fixed& Fixed::operator++() {
 *     ++_fixedPointValue;  // または += 256
 *     return *this;
 * }
 * ```
 * 
 * 後置インクリメント：
 * ```cpp
 * Fixed Fixed::operator++(int) {
 *     Fixed temp(*this);
 *     ++_fixedPointValue;
 *     return temp;  // 変更前の値を返す
 * }
 * ```
 * 
 * 【効率性の考慮】
 * 
 * 1. 前置 vs 後置
 *    - 前置：参照を返す（効率的）
 *    - 後置：コピーを返す（非効率的）
 * 
 * 2. 演算子の戻り値型
 *    - 算術演算：値で返す（一時オブジェクト）
 *    - 比較演算：bool で返す
 *    - 代入演算：参照で返す
 * 
 * 3. const correctness
 *    - 引数：const参照で受け取る
 *    - メンバ関数：変更しない場合はconst
 */

/*
 * ====================================================================
 * 固定小数点演算の数値的課題
 * ====================================================================
 * 
 * 【精度の制限】
 * 
 * 8.8 固定小数点の制約：
 * - 最小単位：1/256 ≈ 0.0039
 * - 表現できない値が多数存在
 * - 累積誤差の発生
 * 
 * 【演算精度の問題】
 * 
 * 1. 乗算
 * ```
 * 問題：内部値同士の乗算で中間結果が大きくなる
 * 対策：適切なスケーリングとオーバーフロー対策
 * ```
 * 
 * 2. 除算
 * ```
 * 問題：ゼロ除算と精度低下
 * 対策：事前チェックと適切な丸め処理
 * ```
 * 
 * 3. 連続演算
 * ```
 * 問題：誤差の累積
 * 対策：演算順序の最適化
 * ```
 * 
 * 【オーバーフロー対策】
 * 
 * 範囲チェック例：
 * ```cpp
 * Fixed operator*(const Fixed& lhs, const Fixed& rhs) {
 *     long long result = static_cast<long long>(lhs.getRawBits()) * 
 *                       static_cast<long long>(rhs.getRawBits());
 *     result >>= 8;  // スケール調整
 *     
 *     if (result > INT_MAX || result < INT_MIN) {
 *         // オーバーフロー処理
 *         throw std::overflow_error("Fixed point overflow");
 *     }
 *     
 *     Fixed ret;
 *     ret.setRawBits(static_cast<int>(result));
 *     return ret;
 * }
 * ```
 */

/*
 * ====================================================================
 * 実用的な応用と発展
 * ====================================================================
 * 
 * 【ゲーム開発での活用】
 * 
 * 座標計算例：
 * ```cpp
 * Fixed x(100.5f), y(200.25f);
 * Fixed velocity_x(1.5f), velocity_y(-2.0f);
 * 
 * // フレーム更新
 * x += velocity_x;
 * y += velocity_y;
 * 
 * // 衝突判定
 * if (x > Fixed(800) || x < Fixed(0)) {
 *     velocity_x = -velocity_x;  // 反射
 * }
 * ```
 * 
 * 【数学ライブラリとの統合】
 * 
 * 三角関数の実装例：
 * ```cpp
 * Fixed sin(const Fixed& angle) {
 *     // テーブル参照または級数展開
 *     return Fixed(std::sin(angle.toFloat()));
 * }
 * ```
 * 
 * 【パフォーマンス最適化】
 * 
 * SIMD使用例：
 * ```cpp
 * // 複数のFixed値を並列計算
 * void vectorAdd(Fixed* a, const Fixed* b, size_t count) {
 *     for (size_t i = 0; i < count; ++i) {
 *         a[i] += b[i];
 *     }
 * }
 * ```
 * 
 * 【他の固定小数点形式】
 * 
 * より高精度な16.16形式：
 * ```cpp
 * class Fixed32 {
 *     int32_t _value;  // 16.16形式
 *     static const int FRACTIONAL_BITS = 16;
 * };
 * ```
 */