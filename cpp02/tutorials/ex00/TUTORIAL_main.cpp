/*
 * ====================================================================
 * CPP02 ex00: Orthodox Canonical Form - メイン関数実用例解説版
 * ====================================================================
 * 
 * このメイン関数でOCFの4要素がどのような場面で呼び出されるかを
 * 学習します。各行でどのコンストラクタ・演算子が実行されるか、
 * オブジェクトのライフサイクルはどうなるかを完全理解します。
 */

#include "Fixed.hpp"

/*
 * ====================================================================
 * main関数の実行フロー完全解析
 * ====================================================================
 * 
 * この関数は4つのオブジェクト操作パターンを示します:
 * 1. デフォルト構築
 * 2. コピー構築  
 * 3. デフォルト構築（再び）
 * 4. 代入操作
 * 
 * 実行時の出力を予測して、実際の動作と比較することが
 * OCF理解の最短ルートです。
 */
int main(void) {
    /*
     * ====================================================================
     * 行4: Fixed a; - デフォルト構築
     * ====================================================================
     * 
     * 呼び出されるもの: Fixed::Fixed(void)
     * 
     * 実行内容:
     * 1. _value = 0 で初期化（初期化リスト）
     * 2. "Default constructor called" 出力
     * 3. オブジェクト a がスタックに作成される
     * 
     * メモリ状態:
     * a._value = 0
     * a の生存期間: main関数終了まで
     * 
     * 重要ポイント:
     * - スタック上のオブジェクト作成
     * - 自動的な生存期間管理
     * - 初期値は 0.0 (実際は0だが固定小数点で0.0を表現)
     */
    Fixed a;
    
    /*
     * ====================================================================
     * 行5: Fixed b(a); - コピー構築
     * ====================================================================
     * 
     * 呼び出されるもの: Fixed::Fixed(const Fixed& other)
     * 
     * 実行フロー:
     * 1. "Copy constructor called" 出力
     * 2. *this = other; 実行
     *    ↓
     * 3. Fixed::operator=(const Fixed& other) 呼び出し
     *    - "Copy assignment operator called" 出力
     *    - this != &other チェック (true)
     *    - other.getRawBits() 呼び出し
     *      → "getRawBits member function called" 出力
     *      → 0 を返却
     *    - this->_value = 0 に設定
     *    - *this を返却
     * 
     * 結果:
     * b._value = 0 (a と同じ値)
     * 
     * 設計上の注意:
     * コピーコンストラクタが代入演算子を呼ぶため
     * 両方のログメッセージが出力される
     * これは一般的だが唯一の実装方法ではない
     */
    Fixed b(a);
    
    /*
     * ====================================================================
     * 行6: Fixed c; - デフォルト構築（2回目）
     * ====================================================================
     * 
     * 呼び出されるもの: Fixed::Fixed(void) (再び)
     * 
     * 実行内容:
     * 1. _value = 0 で初期化
     * 2. "Default constructor called" 出力
     * 3. オブジェクト c がスタックに作成される
     * 
     * 重要な観察:
     * a と c は別々のオブジェクト
     * 値は同じだがメモリ上の異なる場所に存在
     * 
     * メモリレイアウト（概念図）:
     * Stack:
     * +--------+  ← c (最後に作成)
     * | _value |  = 0
     * +--------+
     * +--------+  ← b  
     * | _value |  = 0
     * +--------+
     * +--------+  ← a (最初に作成)
     * | _value |  = 0
     * +--------+
     */
    Fixed c;
    
    /*
     * ====================================================================
     * 行8: c = b; - 代入操作
     * ====================================================================
     * 
     * 呼び出されるもの: Fixed::operator=(const Fixed& other)
     * 
     * 重要な区別:
     * これはコピー構築ではなく代入操作
     * c は既に存在するオブジェクト
     * 
     * 実行フロー:
     * 1. "Copy assignment operator called" 出力
     * 2. this != &other チェック
     *    - this = &c のアドレス
     *    - &other = &b のアドレス  
     *    - 異なるオブジェクトなので true
     * 3. other.getRawBits() 呼び出し (b に対して)
     *    - "getRawBits member function called" 出力
     *    - b._value (= 0) を返却
     * 4. this->_value = 0 に設定 (c._value = 0)
     * 5. *this 返却 (結果は使われない)
     * 
     * 結果:
     * c._value = 0 (変化なし、でも代入処理は実行された)
     * 
     * パフォーマンス考察:
     * 値が同じでも代入処理は実行される
     * より高度な実装では値の比較チェックも可能
     */
    c = b;
    
    /*
     * ====================================================================
     * 行10-12: 値の出力とgetRawBits()の呼び出し
     * ====================================================================
     * 
     * std::cout << a.getRawBits() << std::endl;
     * std::cout << b.getRawBits() << std::endl;
     * std::cout << c.getRawBits() << std::endl;
     * 
     * 実行内容（各行で）:
     * 1. a.getRawBits() 呼び出し
     *    - "getRawBits member function called" 出力
     *    - 0 を返却
     * 2. std::cout << 0 << std::endl; 実行
     *    - "0" を出力
     * 
     * これが3回繰り返される（a, b, c それぞれに対して）
     * 
     * 期待される出力:
     * getRawBits member function called
     * 0
     * getRawBits member function called  
     * 0
     * getRawBits member function called
     * 0
     * 
     * 学習ポイント:
     * - const correctness: getRawBits()はconstメソッド
     * - 単純な値取得でもメソッド呼び出しのオーバーヘッド
     * - デバッグログの価値: どのメソッドがいつ呼ばれるか可視化
     */
    std::cout << a.getRawBits() << std::endl;
    std::cout << b.getRawBits() << std::endl;
    std::cout << c.getRawBits() << std::endl;
    
    /*
     * ====================================================================
     * return 0; とオブジェクトの破棄
     * ====================================================================
     * 
     * main関数の終了時:
     * 
     * 1. スタック上のオブジェクトが逆順で破棄される
     *    C++ の規則: 最後に作成されたものから先に破棄
     * 
     * 破棄順序:
     * 1. c のデストラクタ呼び出し
     *    - "Destructor called" 出力
     * 2. b のデストラクタ呼び出し  
     *    - "Destructor called" 出力
     * 3. a のデストラクタ呼び出し
     *    - "Destructor called" 出力
     * 
     * 重要な確認ポイント:
     * 作成されたオブジェクト数 = 破棄されたオブジェクト数
     * → 3個作成、3個破棄 ✓
     * 
     * これがRAII (Resource Acquisition Is Initialization) の実践
     * 自動的なリソース管理の基礎
     */
    return 0;
}

/*
 * ====================================================================
 * 完全な実行ログの予測
 * ====================================================================
 * 
 * プログラム実行時の完全な出力:
 * 
 * Default constructor called                    ← Fixed a;
 * Copy constructor called                       ← Fixed b(a);
 * Copy assignment operator called               ← *this = other; (コピーコンストラクタ内)
 * getRawBits member function called             ← other.getRawBits() (代入演算子内)
 * Default constructor called                    ← Fixed c;
 * Copy assignment operator called               ← c = b;
 * getRawBits member function called             ← other.getRawBits() (代入演算子内)
 * getRawBits member function called             ← a.getRawBits()
 * 0                                            ← 値の出力
 * getRawBits member function called             ← b.getRawBits()
 * 0                                            ← 値の出力
 * getRawBits member function called             ← c.getRawBits()
 * 0                                            ← 値の出力
 * Destructor called                            ← c のデストラクタ
 * Destructor called                            ← b のデストラクタ
 * Destructor called                            ← a のデストラクタ
 * 
 * メソッド呼び出し回数:
 * - デフォルトコンストラクタ: 2回 (a, c)
 * - コピーコンストラクタ: 1回 (b)
 * - 代入演算子: 2回 (コピーコンストラクタ内 + c = b)
 * - getRawBits: 5回 (代入演算子内×2 + 明示的呼び出し×3)
 * - デストラクタ: 3回 (a, b, c)
 */

/*
 * ====================================================================
 * 学習確認用の実験
 * ====================================================================
 * 
 * このコードを理解したら以下の実験を試してみましょう:
 * 
 * 【実験1: 自己代入のテスト】
 * a = a;  // この行を追加して出力を確認
 * 期待: "Copy assignment operator called" のみ
 *       getRawBits は呼ばれない（自己代入チェックで除外）
 * 
 * 【実験2: 初期化と代入の区別】
 * Fixed d = a;  // これはコピー構築、代入ではない
 * Fixed e;      // デフォルト構築
 * e = a;        // これが代入
 * 
 * 【実験3: スコープによる早期破棄】
 * {
 *     Fixed temp;    // 内側のスコープで作成
 * }                  // ここでtempのデストラクタが呼ばれる
 * // main終了前にtempは既に破棄済み
 * 
 * 【実験4: より複雑な代入】
 * a = b = c;  // 連鎖代入のテスト
 * 期待: 代入演算子が2回呼ばれる
 */

/*
 * ====================================================================
 * よくある混乱と解決法
 * ====================================================================
 * 
 * 【混乱1】なぜコピーコンストラクタで代入演算子が呼ばれる？
 * 回答: Fixed b(a); で Fixed::Fixed(const Fixed& other) が呼ばれ、
 *      その中で *this = other; を実行するため
 * 
 * 【混乱2】Fixed d = a; はコピー構築？代入？
 * 回答: コピー構築。dがまだ存在しないため。
 *      既存オブジェクトへの = のみが代入演算。
 * 
 * 【混乱3】なぜ getRawBits が何度も呼ばれる？
 * 回答: 代入演算子の実装で other.getRawBits() を使用 +
 *      明示的な値出力で各オブジェクトに対して呼び出し
 * 
 * 【混乱4】デストラクタの順序がなぜ逆？
 * 回答: C++の規則。スタック上では最後に作成されたものから
 *      先に破棄（LIFO: Last In, First Out）
 */

/*
 * ====================================================================
 * プロフェッショナルな観点からの分析
 * ====================================================================
 * 
 * 【コードの品質】
 * ✓ OCFが完全に実装されている
 * ✓ メモリ安全性が保証されている
 * ✓ 例外安全性（基本レベル）が確保されている
 * 
 * 【パフォーマンス考察】
 * - コピーコンストラクタでの代入演算子使用は軽微なオーバーヘッド
 * - getRawBits のログ出力は実運用では削除すべき
 * - 自己代入チェックは最適化の余地あり
 * 
 * 【保守性】
 * ✓ 一貫した実装パターン
 * ✓ 明確なインターフェース
 * ✓ 将来の拡張に対応しやすい設計
 * 
 * 【学習価値】
 * ✓ OCFの基本概念が明確に示されている
 * ✓ オブジェクトライフサイクルが可視化されている
 * ✓ C++の基本的なメモリ管理が実践されている
 */

/*
 * ====================================================================
 * 次のステップ
 * ====================================================================
 * 
 * このex00を完全理解したら:
 * 
 * 1. CPP02 ex01: 型変換コンストラクタとtoFloat()
 *    - int/float からの変換
 *    - より実用的なFixed実装
 * 
 * 2. CPP02 ex02: 演算子オーバーロード
 *    - 比較演算子 (<, >, ==, !=)
 *    - 算術演算子 (+, -, *, /)
 *    - インクリメント/デクリメント
 * 
 * 3. CPP02 ex03: BSP (Binary Space Partitioning)
 *    - Fixed クラスの実用的応用
 *    - 幾何学計算での固定小数点使用
 * 
 * 学習の鍵: 各ステップで前の理解を基礎として積み重ねる
 */