Based on the provided PDF file (Subject for C++ Module 08), here is the accurate transcription of the exercises and submission guidelines.

### Chapter V

### Exercise 00: Easy find

  * **Turn-in directory:** `ex00/`
  * **Files to turn in:** `Makefile, main.cpp, easyfind.{h, hpp}` and optional file: `easyfind.tpp`
  * **Forbidden functions:** None

**Instructions:**

  * Write a function template `easyfind` that accepts a type `T`. It takes two parameters: the first one is of type `T`, and the second one is an integer.
  * Assuming `T` is a container of integers, this function has to find the first occurrence of the second parameter in the first parameter.
  * If no occurrence is found, you can either throw an exception or return an error value of your choice.
  * If you need some inspiration, analyze how standard containers behave.
  * Of course, implement and turn in your own tests to ensure everything works as expected.
  * [cite_start]You don't have to handle associative containers. [cite: 933-945]

-----

### Chapter VI

### Exercise 01: Span

  * **Turn-in directory:** `ex01/`
  * **Files to turn in:** `Makefile, main.cpp, Span.{h, hpp}, Span.cpp`
  * **Forbidden functions:** None

**Instructions:**

  * Develop a `Span` class that can store a maximum of `N` integers. `N` is an unsigned int variable and will be the only parameter passed to the constructor.
  * This class will have a member function called `addNumber()` to add a single number to the Span. It will be used in order to fill it. Any attempt to add a new element if there are already `N` elements stored should throw an exception.
  * Next, implement two member functions: `shortestSpan()` and `longestSpan()`
  * They will respectively find out the shortest span or the longest span (or distance, if you prefer) between all the numbers stored, and return it.
  * If there are no numbers stored, or only one, no span can be found. Thus, throw an exception.
  * Of course, you will write your own tests, and they will be far more thorough than the ones below. Test your Span with at least 10,000 numbers. More would be even better.
  * **Range Iterators:** Last but not least, it would be wonderful to fill your Span using a range of iterators. Making thousands of calls to `addNumber()` is so annoying. [cite_start]Implement a member function to add multiple numbers to your Span in a single call. [cite: 950-984]

**Example Main:**
Running this code:

```cpp
int main()
{
    Span sp = Span(5);
    sp.addNumber(6);
    sp.addNumber(3);
    sp.addNumber(17);
    sp.addNumber(9);
    sp.addNumber(11);
    std::cout << sp.shortestSpan() << std::endl;
    std::cout << sp.longestSpan() << std::endl;
    return 0;
}
```

Should output:

```
2
14
```

[cite_start][cite: 965-980]

-----

### Chapter VII

### Exercise 02: Mutated abomination

  * **Turn-in directory:** `ex02/`
  * **Files to turn in:** `Makefile, main.cpp, MutantStack.{h, hpp}` and optional file: `MutantStack.tpp`
  * **Forbidden functions:** None

**Instructions:**

  * The `std::stack` container is very nice. Unfortunately, it is one of the only STL Containers that is NOT iterable.
  * To repair this injustice, you have to make the `std::stack` container iterable.
  * Write a `MutantStack` class. It will be implemented in terms of a `std::stack`.
  * It will offer all its member functions, plus an additional feature: iterators.
  * [cite_start]Of course, you will write and turn in your own tests to ensure everything works as expected. [cite: 990-1002]

**Example Main:**
Find a test example below.

```cpp
int main()
{
    MutantStack<int> mstack;
    mstack.push(5);
    mstack.push(17);
    std::cout << mstack.top() << std::endl;
    mstack.pop();
    std::cout << mstack.size() << std::endl;
    mstack.push(3);
    mstack.push(5);
    mstack.push(737);
    //[...]
    mstack.push(0);
    MutantStack<int>::iterator it = mstack.begin();
    MutantStack<int>::iterator ite = mstack.end();
    ++it;
    --it;
    while (it != ite)
    {
        std::cout << *it << std::endl;
        ++it;
    }
    std::stack<int> s(mstack);
    return 0;
}
```

If you run it a first time with your `MutantStack`, and a second time replacing the `MutantStack` with, for example, a `std::list`, the two outputs should be the same. [cite_start]Of course, when testing another container, update the code below with the corresponding member functions (`push()` can become `push_back()`). [cite: 1006-1033]

-----

### Chapter VIII

### Submission and peer-evaluation

  * Turn in your assignment in your Git repository as usual. Only the work inside your repository will be evaluated during the defense. [cite_start]Don't hesitate to double check the names of your folders and files to ensure they are correct. [cite: 1037-1039]
  * During the evaluation, a brief modification of the project may occasionally be requested.
  * This could involve a minor behavior change, a few lines of code to write or rewrite, or an easy-to-add feature.
  * This step is meant to verify your actual understanding of a specific part of the project.
  * [cite_start]The modification can be performed in any development environment you choose (e.g., your usual setup), and it should be feasible within a few minutes unless a specific timeframe is defined as part of the evaluation. [cite: 1040-1045]