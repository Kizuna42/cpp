C++ Module 04 プロジェクト評価基準

このドキュメントは、C++ Module 04 のプロジェクト評価項目を原文に沿って正確に翻訳したものです。

Ⅰ. 導入およびガイドライン

基本ルール

評価プロセス全体を通して、以下のルールに従ってください：

礼儀正しく、親切で、敬意を払い、建設的であること。コミュニティの健全性はそれにかかっています。

評価対象の学生またはグループと共に、プロジェクトにおける潜在的な機能不全を特定してください。時間をかけて、特定された可能性のある問題について議論し、討論してください。

あなたの仲間がプロジェクトの指示やその機能の範囲をどのように理解したかについては、多少の違いがあるかもしれないことを考慮しなければなりません。常に心を開き、できるだけ正直に評価してください。ピア評価が真剣に行われてこそ、教育は有益なものとなります。

ガイドライン

評価対象の学生またはグループの Git リポジトリに提出された作業のみを評価してください。

Git リポジトリが対象の学生のものであることを再確認してください。プロジェクトが期待されたものであることを確認してください。また、git clone が空のフォルダで使用されていることを確認してください。

あなたを騙し、公式リポジトリの内容ではないものを評価させるような、悪意のあるエイリアスが使用されていないか注意深く確認してください。

不測の事態を避けるため、もし該当する場合は、評価を容易にするために使用されるスクリプト（テストや自動化のためのスクリプト）を一緒にレビューしてください。

評価しようとしている課題を完了していない場合は、評価プロセスを開始する前に課題全体を読む必要があります。

空のリポジトリ、機能しないプログラム、Norm エラー、不正行為などを報告するために、利用可能なフラグを使用してください。

これらの場合、評価プロセスは終了し、最終的な成績は 0、不正行為の場合は-42 となります。ただし、不正行為を除き、将来繰り返すべきでない間違いを特定するために、提出された作業を学生が一緒にレビューすることが強く推奨されます。

設定ファイルが存在する場合を除き、いかなるファイルも編集する必要はありません。ファイルを編集したい場合は、評価対象の学生にその理由を明確に説明し、双方がそれに同意していることを確認してください。

メモリリークがないことも確認しなければなりません。ヒープ上に割り当てられたメモリはすべて、実行終了前に適切に解放されなければなりません。

leaks、valgrind、e_fence など、コンピュータで利用可能なさまざまなツールのいずれを使用しても構いません。メモリリークがあった場合は、適切なフラグを立ててください。

Ⅱ. 課題別評価項目

事前テストと前提条件

不正行為が疑われる場合、評価はここで停止します。報告には「Cheat」フラグを使用してください。この決定は冷静に、賢明に行い、このボタンは慎重に使用してください。

コードは c++と-Wall -Wextra -Werror のフラグでコンパイルできなければなりません。

このプロジェクトは C++98 標準に従う必要があることを忘れないでください。したがって、C++11（およびそれ以降）の関数やコンテナは期待されていません。

以下のいずれかに該当する場合、対象の演習を評価してはなりません：

関数がヘッダーファイルに実装されている（テンプレート関数を除く）。

Makefile が必要なフラグなしで、または c++以外のコンパイラでコンパイルされる。

以下のいずれかに該当する場合、プロジェクトに「Forbidden Function」のフラグを立てなければなりません：

"C"関数（*alloc, *printf, free）の使用。

演習のガイドラインで許可されていない関数の使用。

「using namespace」または「friend」キーワードの使用。

外部ライブラリ、または C++98 以外のバージョンの機能の使用。

Ex00: Polymorphism (ポリモーフィズム)

必須条件:

プログラムが期待通りに動作することを証明するのに十分なテストを含む main 関数がなければなりません。ない場合は、この演習を評価しないでください。

インターフェースでないクラスが Orthodox Canonical Class Form（正規クラス形式）でない場合は、この演習を評価しないでください。

Animal クラス:

type という名前の一つの string 属性を持つ Animal クラスが存在すること。

このクラスをインスタンス化して使用できること。

継承:

Animal から継承する Cat と Dog という少なくとも 2 つのクラスが存在すること。

コンストラクタとデストラクタの出力が明確であること。コンストラクタとデストラクタの順序について学生に質問してください。

type 属性:

type 属性は、すべての動物の作成時に適切な値に設定されること。Cat は "Cat"、Dog は "Dog" でなければなりません。

makeSound()関数:

makeSound()関数を使用すると、常に適切な makeSound()関数が呼び出されること。makeSound()は virtual でなければなりません！コードでそれを確認してください。(virtual void makeSound() const)

戻り値は重要ではありませんが、virtual キーワードは必須です。

virtual キーワードを使用しない WrongAnimal と WrongCat の例があるべきです（課題参照）。

WrongCat は、WrongCat として使用された場合にのみ、WrongCat の makeSound()を出力しなければなりません。

Ex01: I do not want to set the world on fire

必須条件:

main 関数と Orthodox Canonical Class Form の条件は Ex00 と同様。

具象 Animal:

Brain という新しいクラスが存在すること。

Cat と Dog は、要求される private な Brain 属性を持っていること。

Brain 属性は Animal クラス内にあってはなりません。

Brain クラスは、作成時と削除時に特定の出力をすること。

ディープコピー:

Cat または Dog のコピーはディープコピーであるべきです。

次のようなテストを行ってください：

Dog basic;
{
Dog tmp = basic;
}

コピーがシャローな場合、tmp と basic は同じ Brain を使用し、その Brain はスコープの終わりに tmp と共に削除されてしまいます。

コピーコンストラクタもディープコピーを行うべきです。

デストラクタの連鎖:

Animal とその派生クラスのデストラクタは virtual であること。

virtual キーワードがない場合に何が起こるか説明を求めてください。それをテストしてください。

代入とコピー:

Cat と Dog のコピーと代入の振る舞いが、課題の要求通りであること。

ディープコピーとは、Cat または Dog のために新しい Brain を作成する必要があることを意味します。Canonical Form が本当に実装されていることを確認してください（例：空のコピー代入演算子などがない）。理由なく public にされているものがあってはなりません。さらに、このコードは非常にシンプルなので、クリーンである必要があります！

Ex02: Abstract class (抽象クラス)

必須条件:

main 関数と Orthodox Canonical Class Form の条件は Ex00 と同様。

抽象クラス:

課題にあるものと全く同じ Animal クラスが存在すること。

Animal::makeSound は純粋仮想関数であること。

それは virtual void makeSound() const = 0; のようになっているべきです。"= 0"の部分は必須です。

Animal をインスタンス化できてはなりません。(Animal test; はクラスが抽象であることに関するコンパイルエラーを出すべきです)。

具象 Animal:

Cat と Dog クラスは引き続き存在し、ex01 と全く同じように動作すること。

Ex03: Interface and recap (インターフェースとまとめ)

必須条件:

main 関数と Orthodox Canonical Class Form の条件は Ex00 と同様。

インターフェース:

課題で要求されているものと全く同じ ICharacter と IMateriaSource インターフェースが存在すること。

MateriaSource:

MateriaSource クラスが存在し、IMateriaSource を実装していること。メンバー関数は意図通りに動作すること。

具象 Materia:

AMateria から継承する具象クラス Ice と Cure が存在すること。それらの clone()メソッドは正しく実装されていること。それらの出力は正しいこと。

AMateria クラスは依然として抽象であること（clone()は純粋仮想関数）。

virtual ~AMateria()が存在すること。

AMateria は type を保存するための protected な string 属性を含むこと。

Character:

Character クラスが存在し、ICharacter を実装していること。最大 4 つの Materia のインベントリを持っていること。

メンバー関数は課題の要求通りに実装されていること。

Character のコピーと代入は要求通り（ディープコピー）に実装されていること。

Ⅲ. レビューでの想定問答集 (Q&A)

Ex00: Polymorphism (ポリモーフィズム)

質問 1: Dog のような派生クラスのオブジェクトを生成した際、コンストラクタとデストラクタはどのような順序で呼ばれますか？

模範解答: オブジェクト生成時には、まず基底クラスである Animal のコンストラクタが呼ばれ、その後で派生クラスである Dog のコンストラクタが呼ばれます。オブジェクトが破棄される際にはその逆で、まず Dog のデストラクタが呼ばれ、次に Animal のデストラクタが呼ばれます。

質問 2: makeSound()関数についている virtual キーワードの役割は何ですか？ もし基底クラスのポインタ経由でこの関数を呼び出すときに virtual がなかったら、どうなりますか？

模範解答: virtual キーワードは、関数の動的束縛（実行時ポリモーフィズム）を可能にします。基底クラスのポインタがどの派生クラスのオブジェクトを指しているかに応じて、実行時に呼び出すべき関数を決定します。もし virtual がない場合、静的束縛となり、ポインタの型（この場合は Animal\*）に基づいて関数が呼ばれます。つまり、Animal の makeSound()が常に呼ばれてしまい、Dog や Cat の makeSound()は呼ばれません。

Ex01: I do not want to set the world on fire

質問 1: なぜ Cat や Dog クラスのコピーは、ディープコピーである必要があるのですか？シャローコピー（浅いコピー）だとどのような問題が発生しますか？

模範解答: Cat や Dog は内部で Brain オブジェクトへのポインタを保持しているためです。シャローコピーを行うと、コピー元とコピー先のオブジェクトが同じ Brain オブジェクトを指してしまいます。その結果、片方のオブジェクトが破棄されると Brain も解放され、もう片方のオブジェクトが解放済みのメモリ（ダングリングポインタ）を指すことになり、未定義の動作やクラッシュを引き起こします。ディープコピーでは、Brain オブジェクト自体も複製するため、各オブジェクトが独立したメモリを持つことになり、この問題を回避できます。

質問 2: なぜ基底クラスである Animal のデストラクタは virtual でなければならないのですか？

模範解答: 基底クラスのポインタを通じて派生クラスのオブジェクトを delete する際に、意図しない動作を防ぐためです。デストラクタが virtual でない場合、delete されたポインタの型（Animal\*）のデストラクタしか呼ばれません。これにより、派生クラス（Dog など）のデストラクタが呼ばれず、派生クラスで確保したリソース（この課題では Brain オブジェクト）が解放されない、メモリリークの原因となります。デストラクタを virtual にすることで、派生クラスのデストラクタが正しく呼ばれることが保証されます。

Ex02: Abstract class (抽象クラス)

質問 1: 純粋仮想関数とは何ですか？また、それを持つクラス（抽象クラス）をなぜインスタンス化できないのですか？

模範解答: 純粋仮想関数は、宣言のみで実装を持たない仮想関数です（= 0;と記述します）。これを持つクラスは抽象クラスとなり、派生クラスにその関数の実装を強制する「インターフェース」の役割を果たします。実装が定義されていない関数があるため、抽象クラスのオブジェクトを直接生成することはできません。インスタンス化するには、全ての純粋仮想関数をオーバーライドした具象クラス（Concrete Class）を作成する必要があります。

Ex03: Interface and recap (インターフェースとまとめ)

質問 1: この課題における「インターフェース」とは何ですか？

模範解答: この課題におけるインターフェース（ICharacter や IMateriaSource）は、純粋仮想関数のみで構成された抽象クラスのことです。これにより、クラスがどのような機能（メソッド）を持つべきかを定義する「契約」のような役割を果たします。このインターフェースを継承するクラスは、インターフェースで定義された全ての純粋仮想関数を実装することが強制されるため、クラスの振る舞いに一貫性を持たせることができます。

質問 2: Character のコピー代入演算子を実装する際に、どのような点に注意しましたか？

模範解答: 自己代入（*this = *this;）のケースを正しく処理することと、ディープコピーを確実に行うことに注意しました。まず、代入元のアドレスが自分自身でないことを確認します。次に、元々インベントリに保持していた Materia を全て解放し、その後、代入元の Materia を一つずつ clone()して新しい Materia を生成し、自分のインベントリにセットします。これにより、メモリリークを防ぎつつ、独立したディープコピーを実現しました。

Ⅳ. 追加の想定質問と補足説明

Ex00: Polymorphism - 追加質問

質問 3: vtable（仮想関数テーブル）とは何ですか？virtual キーワードがある場合、コンパイラはどのように動的束縛を実現していますか？

模範解答: vtable（仮想関数テーブル）は、クラスが持つ仮想関数へのポインタを格納したテーブルです。virtual キーワードを使用すると、コンパイラは各クラスに対して vtable を生成し、各オブジェクトには「vptr（vtable へのポインタ）」という隠しメンバが追加されます。関数呼び出し時には、この vptr を使って vtable を参照し、実際のオブジェクトの型に応じた関数を呼び出します。これにより実行時に正しい関数が選択される動的束縛が実現されます。

質問 4: WrongAnimal と WrongCat の例から、どのような教訓が得られますか？

模範解答: virtual キーワードを付け忘れると、ポリモーフィズムが機能せず、基底クラスのポインタ経由では派生クラス固有の動作が呼び出されないという教訓が得られます。これは実務上のバグの原因となりやすく、特にデストラクタを virtual にし忘れるとメモリリークを引き起こします。したがって、継承を使用する基底クラスでは、必ずデストラクタを virtual にすることがベストプラクティスです。

Ex01: Brain - 追加質問

質問 3: コピーコンストラクタと代入演算子の違いは何ですか？なぜ両方を実装する必要があるのですか？

模範解答: コピーコンストラクタは新しいオブジェクトの初期化時に呼ばれ、代入演算子は既に存在するオブジェクトに値を代入する際に呼ばれます。主な違いは、代入演算子では既存のリソース（この課題では Brain\*）を先に解放する必要があるという点です。両方を実装しないと、一方でのみディープコピーが行われ、もう一方ではシャローコピーになってしまい、メモリ管理の不整合が発生します。Orthodox Canonical Form では、両方を一貫した方法で実装することが求められます。

質問 4: もし Animal のデストラクタが virtual でない場合、具体的にどのようなメモリリークが発生しますか？実際の出力を示してください。

模範解答: 次のようなコードの場合、

```cpp
Animal* dog = new Dog();
delete dog;
```

デストラクタが virtual でないと、Animal::~Animal()のみが呼ばれ、Dog::~Dog()が呼ばれません。その結果、Dog クラスのデストラクタ内で行うべき Brain オブジェクトの delete 処理が実行されず、Brain のメモリがリークします。出力では「Dog destructor called」と「Brain destructor called」が表示されないことで確認できます。

質問 5: 「Rule of Three」とは何ですか？この課題とどう関連していますか？

模範解答: Rule of Three とは、C++において「デストラクタ」「コピーコンストラクタ」「コピー代入演算子」の 3 つのうち 1 つでも明示的に定義する必要がある場合、残りの 2 つも明示的に定義すべきという原則です。この課題では、Dog クラスが new で確保した Brain\*を持つため、デストラクタで delete する必要があります。その場合、自動生成されるコピーコンストラクタと代入演算子はシャローコピーを行うため不適切です。したがって、3 つ全てを明示的に実装し、ディープコピーを実現する必要があります。この原則は Orthodox Canonical Form の基礎となっています。

Ex02: Abstract Class - 追加質問

質問 2: 純粋仮想関数を持つ抽象クラスでも、コンストラクタやデストラクタは実装できますか？またそれは何のためですか？

模範解答: はい、実装できます。抽象クラスは直接インスタンス化できませんが、派生クラスのオブジェクトを生成する際には基底クラスのコンストラクタが呼ばれます。そのため、共通の初期化処理（この課題では type 属性の初期化など）をコンストラクタで行うことは有効です。デストラクタも同様で、特に virtual デストラクタは派生クラスのリソース解放を保証するために必須です。抽象クラスはインスタンス化できないだけで、通常のクラスと同じようにコンストラクタ/デストラクタを持つことができます。

質問 3: C++において、純粋仮想関数に実装を与えることは可能ですか？

模範解答: はい、技術的には可能です。純粋仮想関数に`= 0`を付けつつ、別途実装を定義することができます。ただし、そのクラスは依然として抽象クラスのままです。この実装は、派生クラスが`BaseClass::function()`のように明示的に呼び出すことで使用できます。しかし、一般的な用途ではこの手法は使われず、通常は純粋仮想関数は実装を持ちません。この課題では、純粋仮想関数は実装を持たないインターフェースとして使用します。

Ex03: Interface - 追加質問

質問 3: なぜ unequip()で Materia を delete してはいけないのですか？どのように管理すべきですか？

模範解答: unequip()で Materia をすぐに delete すると、後で使用したい場合に問題が発生します。課題の要求では、unequip された Materia は「地面に落ちる」という概念で、後で cleanup する仕組みが必要です。一般的な実装方法は、unequip された Materia を別のコンテナ（配列やリスト）で保持し、プログラム終了時やキャラクターのデストラクタで一括して delete する方法です。これにより、メモリリークを防ぎつつ、Materia を安全に管理できます。

質問 4: ICharacter や IMateriaSource のようなインターフェースに virtual デストラクタが必要な理由は何ですか？

模範解答: インターフェース経由（ICharacter\*など）で派生クラスのオブジェクトを delete する可能性があるためです。virtual デストラクタがないと、インターフェースのデストラクタのみが呼ばれ、派生クラス（Character）のデストラクタが呼ばれません。その結果、Character が持つインベントリの Materia が delete されず、メモリリークが発生します。C++では、ポリモーフィズムを使用する基底クラス（インターフェースを含む）には必ず virtual デストラクタを実装することがベストプラクティスです。

質問 5: clone()メソッドはどのようなデザインパターンですか？なぜこのパターンが有効なのですか？

模範解答: clone()メソッドは「Prototype パターン」と呼ばれるデザインパターンです。このパターンでは、オブジェクト自身がコピーを作成する責任を持ちます。AMateria\*型のポインタ経由で Ice や Cure を扱う場合、具体的な型が分からなくても clone()を呼ぶだけで正しい型のコピーが生成されます。これにより、型に依存しない柔軟なコピー処理が実現でき、ポリモーフィズムと組み合わせることで、拡張性の高いコード設計が可能になります。

Ⅴ. 実践的なテストケース集

以下は、評価時に実際に試すことができるテストケースのコード例です。

Ex00: コンストラクタ/デストラクタ順序の確認テスト

```cpp
// test_constructor_order.cpp
#include "Animal.hpp"
#include "Dog.hpp"
#include <iostream>

int main() {
    std::cout << "=== Creating Dog ===" << std::endl;
    Dog dog;

    std::cout << "\n=== Exiting scope ===" << std::endl;
    return 0;
}

// 期待される出力:
// === Creating Dog ===
// Animal Dog constructor called
// Dog constructor called
//
// === Exiting scope ===
// Dog destructor called
// Animal Dog destructor called
```

Ex00: virtual の有無による動作の違い確認テスト

```cpp
// test_virtual_behavior.cpp
#include "Animal.hpp"
#include "Dog.hpp"
#include "Cat.hpp"
#include "WrongAnimal.hpp"
#include "WrongCat.hpp"
#include <iostream>

int main() {
    std::cout << "=== Correct (with virtual) ===" << std::endl;
    const Animal* cat = new Cat();
    cat->makeSound();  // Should output "Meow! Meow!"
    delete cat;

    std::cout << "\n=== Wrong (without virtual) ===" << std::endl;
    const WrongAnimal* wrongCat = new WrongCat();
    wrongCat->makeSound();  // Should output "WrongAnimal makes a wrong animal sound"
    delete wrongCat;

    return 0;
}
```

Ex01: ディープコピー検証テスト（評価項目指定）

```cpp
// test_deep_copy.cpp
#include "Dog.hpp"
#include <iostream>

int main() {
    std::cout << "=== Scope Test (from evaluation sheet) ===" << std::endl;
    Dog basic;
    basic.setIdea(0, "Original idea");

    std::cout << "\n--- Entering inner scope ---" << std::endl;
    {
        Dog tmp = basic;  // Copy constructor
        tmp.setIdea(0, "Temporary idea");
        std::cout << "tmp idea: " << tmp.getBrain()->getIdea(0) << std::endl;
    }
    std::cout << "--- Exited inner scope ---" << std::endl;

    // If shallow copy, basic would have a dangling pointer here!
    std::cout << "\nbasic idea (should still work): "
              << basic.getBrain()->getIdea(0) << std::endl;

    std::cout << "\n=== Assignment Operator Test ===" << std::endl;
    Dog dog1;
    dog1.setIdea(0, "Dog1 idea");

    Dog dog2;
    dog2.setIdea(0, "Dog2 idea");

    dog2 = dog1;  // Assignment operator

    dog1.setIdea(0, "Dog1 modified");

    std::cout << "dog1 idea: " << dog1.getBrain()->getIdea(0) << std::endl;
    std::cout << "dog2 idea (should be old dog1 idea): "
              << dog2.getBrain()->getIdea(0) << std::endl;

    return 0;
}
```

Ex01: virtual デストラクタの重要性テスト

```cpp
// test_virtual_destructor.cpp
#include "Animal.hpp"
#include "Dog.hpp"
#include <iostream>

int main() {
    std::cout << "=== Testing virtual destructor ===" << std::endl;
    std::cout << "Creating Dog through Animal pointer:" << std::endl;

    Animal* animal = new Dog();

    std::cout << "\nDeleting through Animal pointer:" << std::endl;
    delete animal;  // Should call both Dog and Animal destructors

    std::cout << "\n=== Expected output ===" << std::endl;
    std::cout << "Dog destructor called" << std::endl;
    std::cout << "Brain destructor called" << std::endl;
    std::cout << "Animal Dog destructor called" << std::endl;

    std::cout << "\nIf destructor is not virtual, only Animal destructor is called!" << std::endl;
    std::cout << "Result: Brain memory leak!" << std::endl;

    return 0;
}
```

Ex01: Brain アドレス比較テスト

```cpp
// test_brain_address.cpp
#include "Dog.hpp"
#include "Cat.hpp"
#include <iostream>

int main() {
    std::cout << "=== Brain Address Verification ===" << std::endl;

    Dog dog1;
    Dog dog2(dog1);  // Copy constructor

    std::cout << "dog1 Brain address: " << dog1.getBrain() << std::endl;
    std::cout << "dog2 Brain address: " << dog2.getBrain() << std::endl;

    if (dog1.getBrain() == dog2.getBrain()) {
        std::cout << "❌ FAIL: Shallow copy detected!" << std::endl;
        std::cout << "   Both dogs share the same Brain object." << std::endl;
    } else {
        std::cout << "✅ PASS: Deep copy confirmed!" << std::endl;
        std::cout << "   Each dog has its own Brain object." << std::endl;
    }

    std::cout << "\n=== Assignment Operator Test ===" << std::endl;
    Cat cat1;
    Cat cat2;

    std::cout << "Before assignment:" << std::endl;
    std::cout << "cat2 Brain address: " << cat2.getBrain() << std::endl;

    cat2 = cat1;  // Assignment operator

    std::cout << "After assignment:" << std::endl;
    std::cout << "cat1 Brain address: " << cat1.getBrain() << std::endl;
    std::cout << "cat2 Brain address: " << cat2.getBrain() << std::endl;

    if (cat1.getBrain() == cat2.getBrain()) {
        std::cout << "❌ FAIL: Shallow copy in assignment!" << std::endl;
    } else {
        std::cout << "✅ PASS: Deep copy in assignment!" << std::endl;
    }

    return 0;
}
```

Ex02: 抽象クラスのインスタンス化エラーテスト

```cpp
// test_abstract_instantiation.cpp
#include "AAnimal.hpp"

int main() {
    // This should cause a compilation error!
    // Uncomment the following line to test:
    // AAnimal animal;  // ERROR: cannot declare variable 'animal' to be of abstract type 'AAnimal'

    std::cout << "If this compiles with the line uncommented, " << std::endl;
    std::cout << "AAnimal is NOT abstract!" << std::endl;

    return 0;
}

// Expected compilation error:
// error: cannot declare variable 'animal' to be of abstract type 'AAnimal'
// note: because the following virtual functions are pure within 'AAnimal':
// note:     virtual void AAnimal::makeSound() const
```

Ex03: unequip 後のメモリ管理テスト

```cpp
// test_unequip_memory.cpp
#include "Character.hpp"
#include "Ice.hpp"
#include "Cure.hpp"
#include <iostream>

int main() {
    std::cout << "=== Testing unequip memory management ===" << std::endl;

    Character* character = new Character("test");

    AMateria* ice = new Ice();
    character->equip(ice);

    std::cout << "\nUnequipping materia..." << std::endl;
    character->unequip(0);

    std::cout << "\nDeleting character..." << std::endl;
    delete character;

    std::cout << "\nNote: If implementation is correct:" << std::endl;
    std::cout << "- Materia should be stored (ground system)" << std::endl;
    std::cout << "- Materia should be deleted when appropriate" << std::endl;
    std::cout << "- No memory leaks or double-free" << std::endl;

    // Check with valgrind or leaks tool

    return 0;
}
```

Ex03: clone()メソッドの動作確認テスト

```cpp
// test_clone_method.cpp
#include "Ice.hpp"
#include "Cure.hpp"
#include "AMateria.hpp"
#include <iostream>

int main() {
    std::cout << "=== Testing clone() method ===" << std::endl;

    AMateria* original = new Ice();
    AMateria* cloned = original->clone();

    std::cout << "Original type: " << original->getType() << std::endl;
    std::cout << "Cloned type: " << cloned->getType() << std::endl;

    std::cout << "\nOriginal address: " << original << std::endl;
    std::cout << "Cloned address: " << cloned << std::endl;

    if (original == cloned) {
        std::cout << "❌ FAIL: clone() returned same object!" << std::endl;
    } else {
        std::cout << "✅ PASS: clone() created new object!" << std::endl;
    }

    delete original;
    delete cloned;

    return 0;
}
```

Ex03: 自己代入のテスト

```cpp
// test_self_assignment.cpp
#include "Character.hpp"
#include "Ice.hpp"
#include <iostream>

int main() {
    std::cout << "=== Testing self-assignment ===" << std::endl;

    Character character("test");
    character.equip(new Ice());

    std::cout << "\nBefore self-assignment:" << std::endl;
    character.printInventory();

    std::cout << "\nPerforming self-assignment..." << std::endl;
    character = character;  // Self-assignment!

    std::cout << "\nAfter self-assignment:" << std::endl;
    character.printInventory();

    std::cout << "\nUsing materia (should still work):" << std::endl;
    Character target("target");
    character.use(0, target);

    std::cout << "\n✅ If program doesn't crash, self-assignment is handled correctly!" << std::endl;

    return 0;
}
```

Ⅵ. よくある実装ミスと確認ポイント

Ex00 でよくあるミス:

1. ❌ makeSound()に virtual を付け忘れる

   - 確認: Animal\*経由で Dog/Cat を呼び出して、正しい makeSound()が呼ばれるか

2. ❌ デストラクタを virtual にしていない

   - 確認: Animal\* dog = new Dog(); delete dog; で Dog のデストラクタが呼ばれるか

3. ❌ WrongCat の実装を忘れる
   - 確認: virtual なしの比較例があるか

Ex01 でよくあるミス:

1. ❌ シャローコピー（ポインタをコピーするだけ）

   - 確認: Brain のアドレスが異なるか、スコープテストで動作するか

2. ❌ 代入演算子で既存の Brain を delete しない

   - 確認: valgrind/leaks でメモリリークがないか

3. ❌ Brain を Animal クラスに入れてしまう
   - 確認: Cat/Dog クラスの private メンバとして実装されているか

Ex02 でよくあるミス:

1. ❌ makeSound()を純粋仮想関数にしていない（= 0 がない）

   - 確認: AAnimal animal; がコンパイルエラーになるか

2. ❌ ex01 からのコピーミス（Animal のまま）
   - 確認: クラス名が AAnimal になっているか

Ex03 でよくあるミス:

1. ❌ unequip で Materia をすぐに delete してしまう

   - 確認: unequip 後にメモリエラーが起きないか

2. ❌ インベントリのサイズを間違える（4 つではない）

   - 確認: 5 つ目の equip が失敗するか

3. ❌ clone()の実装ミス（シャローコピー）

   - 確認: clone された Materia のアドレスが異なるか

4. ❌ インターフェースのデストラクタが virtual でない

   - 確認: ICharacter\*経由で delete しても正しくデストラクタが呼ばれるか

5. ❌ 自己代入のチェックがない
   - 確認: character = character; でクラッシュしないか

Ⅶ. 実行可能なテストケース

本ドキュメントの Ⅴ 章に記載されているテストケースは、`test_examples/`ディレクトリに実装されています。

利用可能なテスト:

```bash
cd test_examples/

# 個別テスト実行
make test_constructor    # Ex00: コンストラクタ/デストラクタ順序
make test_scope          # Ex01: ディープコピー（スコープテスト）
make test_address        # Ex01: Brainアドレス比較
make test_destructor     # Ex01: virtualデストラクタ
make test_assignment     # Ex03: 自己代入

# 全テスト実行
make run_all
```

詳細な使用方法は `test_examples/README.md` を参照してください。

これらのテストケースを使用することで:
✅ 実装が評価項目を満たしているか実践的に確認できる
✅ レビュー時の質問に対して、実際の動作を示すことができる
✅ ディープコピー、virtual デストラクタなどの概念を視覚的に説明できる
