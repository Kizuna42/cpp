/*
 * ====================================================================
 * CPP01 ex01: Moar brainz! - Zombie クラス実装解説版
 * ====================================================================
 * 
 * この実装は ex00 の Zombie クラスと基本的に同じですが、
 * ex01 では特にデフォルトコンストラクタと setName() の重要性が
 * 格段に高まります。配列での使用を前提とした解説を行います。
 */

#include "Zombie.hpp"

/*
 * ====================================================================
 * デフォルトコンストラクタ実装解説
 * ====================================================================
 */
Zombie::Zombie(void) : _name("Unknown") {
    /*
     * 【ex01でのデフォルトコンストラクタの重要性】
     * 
     * ex00 では「あると便利」だったデフォルトコンストラクタが
     * ex01 では「絶対に必要」になる理由：
     * 
     * 1. 配列初期化の制約
     *    - new Zombie[N] は各要素をデフォルトコンストラクタで初期化
     *    - 引数付きコンストラクタは配列では使用不可（C++98）
     *    - デフォルトコンストラクタがないとコンパイルエラー
     * 
     * 2. 統一的な初期化
     *    - 全要素が "Unknown" で開始
     *    - その後 setName() で統一的に名前変更
     *    - 予測可能な初期状態を保証
     * 
     * 3. メモリ効率
     *    - new[] は一度に連続したメモリを確保
     *    - 各要素の構築は順次実行
     *    - デフォルト初期化が最も効率的
     */
    
    /*
     * 【初期化リストの使用】
     * : _name("Unknown")
     * 
     * なぜコンストラクタ本体ではなく初期化リストを使うのか？
     * 
     * 効率面：
     * - 初期化リスト: オブジェクト作成時に直接初期化
     * - 本体での代入: オブジェクト作成後に値を変更
     * 
     * 比較例：
     * ```cpp
     * // 初期化リスト（推奨）
     * Zombie::Zombie() : _name("Unknown") {}
     * 
     * // 本体での代入（非効率）
     * Zombie::Zombie() {
     *     _name = "Unknown";  // デフォルト構築→代入の2段階
     * }
     * ```
     * 
     * std::string の場合：
     * - 初期化リスト: ""→"Unknown" の1回構築
     * - 本体代入: ""→""→"Unknown" の2回操作
     */
    
    /*
     * 【ログ出力の意義】
     * 
     * デバッグとメモリ管理の確認：
     * - オブジェクトがいつ作られたかを追跡
     * - 配列作成時は N回 このメッセージが出力される
     * - "created" と "destroyed" の数を比較してメモリリーク検出
     * 
     * 出力例（zombieHorde(3, "Walker") の場合）：
     * "Zombie Unknown created"  ← 1個目
     * "Zombie Unknown created"  ← 2個目  
     * "Zombie Unknown created"  ← 3個目
     * （この後、setName で "Walker" に変更される）
     */
    std::cout << "Zombie " << this->_name << " created" << std::endl;
    
    /*
     * 【this ポインタの使用について】
     * 
     * this->_name vs _name の使い分け：
     * 
     * 技術的には同じ：
     * - this->_name: 明示的にthisポインタ経由でアクセス
     * - _name: 暗黙的にthisポインタ経由でアクセス
     * 
     * 42スクールでの推奨理由：
     * 1. 可読性: メンバ変数であることが明確
     * 2. 一貫性: 全てのメンバアクセスで統一
     * 3. 学習効果: ポインタとオブジェクトの関係を意識
     * 
     * 特に配列では重要：
     * - horde[i] の各要素が異なるthisポインタを持つ
     * - 各オブジェクトが独立したメモリ領域を持つ
     */
}

/*
 * ====================================================================
 * 引数付きコンストラクタ実装解説
 * ====================================================================
 */
Zombie::Zombie(std::string name) : _name(name) {
    /*
     * 【ex01での引数付きコンストラクタの位置づけ】
     * 
     * 使用頻度の変化：
     * - ex00: メイン使用（newZombie関数で活用）
     * - ex01: サブ使用（配列では使用不可のため）
     * 
     * しかし重要性は変わらず：
     * 1. 単体テスト時の個別作成
     * 2. 配列以外での Zombie 作成
     * 3. ex00 との互換性維持
     * 4. 将来の拡張への対応
     */
    
    /*
     * 【パラメータ受け渡しの設計】
     * 
     * std::string name で値渡しする理由：
     * 
     * 安全性：
     * - 呼び出し元の文字列が変更されても影響なし
     * - コピーされるため所有権が明確
     * 
     * シンプルさ：
     * - const参照（const std::string& name）より理解しやすい
     * - C++98 レベルでの標準的なパターン
     * 
     * パフォーマンス：
     * - 短い文字列なら値渡しでも問題なし
     * - オブジェクト作成自体が重い処理なので相対的に軽微
     */
    
    /*
     * 【初期化リストでの直接初期化】
     * : _name(name)
     * 
     * 引数からメンバ変数への効率的な転送：
     * - 引数のnameをコピーして_nameを直接構築
     * - デフォルト構築→代入の2段階を回避
     * - std::string の場合、特に効率的
     */
    
    std::cout << "Zombie " << this->_name << " created" << std::endl;
    
    /*
     * 【ログ出力での名前表示】
     * 
     * デフォルトコンストラクタとの違い：
     * - デフォルト: "Zombie Unknown created"
     * - 引数付き: "Zombie [指定した名前] created"  
     * 
     * デバッグ時の利点：
     * - どの名前で作成されたかが即座に分かる
     * - 異なる作成方法を区別できる
     * - メモリ追跡がより詳細になる
     */
}

/*
 * ====================================================================
 * デストラクタ実装解説
 * ====================================================================
 */
Zombie::~Zombie(void) {
    /*
     * 【ex01でのデストラクタの重要性】
     * 
     * 配列解放時の動作：
     * - delete[] horde; で配列全体を解放
     * - 各要素のデストラクタが順次呼び出される
     * - N個のオブジェクトで N回 デストラクタが実行される
     * 
     * メモリリーク検出の鍵：
     * - "created" ログの数と "destroyed" ログの数を比較
     * - 数が一致すれば正常（メモリリークなし）
     * - 数が不一致なら delete[] 忘れの可能性
     */
    
    /*
     * 【解放順序の重要性】
     * 
     * 配列の解放順序（実装依存だが一般的には）：
     * - horde[N-1] から horde[0] の順（逆順）
     * - または horde[0] から horde[N-1] の順（正順）
     * - 順序は実装に依存するが、全要素で確実に呼ばれる
     * 
     * 出力例（horde[3]、name="Walker"の場合）：
     * "Zombie Walker destroyed"  ← horde[2] または horde[0]
     * "Zombie Walker destroyed"  ← horde[1]
     * "Zombie Walker destroyed"  ← horde[0] または horde[2]
     */
    
    std::cout << "Zombie " << this->_name << " destroyed" << std::endl;
    
    /*
     * 【リソース管理の自動化】
     * 
     * C++ の RAII 原則：
     * - Resource Acquisition Is Initialization
     * - オブジェクトの生存期間 = リソースの生存期間
     * - デストラクタで自動的にリソース解放
     * 
     * Zombie クラスの場合：
     * - _name は std::string（自動的にメモリ管理される）
     * - 明示的な delete や free は不要
     * - デストラクタは主にログ出力のために使用
     * 
     * より複雑なクラスでは：
     * - 動的に確保したメモリの解放
     * - ファイルハンドルのクローズ
     * - ネットワーク接続の切断
     * などをデストラクタで実行
     */
}

/*
 * ====================================================================
 * announce メンバ関数実装解説
 * ====================================================================
 */
void Zombie::announce(void) {
    /*
     * 【ex01でのannounceの使用パターン】
     * 
     * 典型的な呼び出し方：
     * ```cpp
     * Zombie* horde = zombieHorde(5, "Walker");
     * for (int i = 0; i < 5; i++) {
     *     horde[i].announce();  // 各要素で個別に呼び出し
     * }
     * ```
     * 
     * 重要な概念：
     * - 配列の各要素は独立したオブジェクト
     * - 各オブジェクトが自分の _name を使って announce
     * - 同じ名前でも、メモリ上は別々の std::string オブジェクト
     */
    
    /*
     * 【出力メッセージの意味】
     * 
     * "BraiiiiiiinnnzzzZ..." の由来：
     * - ゾンビの鳴き声「脳みそ〜」の英語表現
     * - "Brain" を引き延ばした表現
     * - ゾンビの特徴的な行動を表現
     */
    std::cout << this->_name << ": BraiiiiiiinnnzzzZ..." << std::endl;
    
    /*
     * 【配列使用時の出力例】
     * 
     * zombieHorde(3, "Walker") → announce() 3回呼び出し：
     * "Walker: BraiiiiiiinnnzzzZ..."  ← horde[0]
     * "Walker: BraiiiiiiinnnzzzZ..."  ← horde[1]  
     * "Walker: BraiiiiiiinnnzzzZ..."  ← horde[2]
     * 
     * 同じメッセージでも：
     * - 3つの異なるオブジェクトが出力
     * - 3つの異なる this ポインタが関与
     * - 3つの異なる _name メンバ変数を参照
     */
}

/*
 * ====================================================================
 * setName メンバ関数実装解説
 * ====================================================================
 */
void Zombie::setName(std::string name) {
    /*
     * 【ex01での setName の核心的重要性】
     * 
     * なぜ ex01 で急に重要になるのか？
     * 
     * 配列初期化の制約：
     * - new Zombie[N] では全要素がデフォルトコンストラクタで初期化
     * - 引数付きコンストラクタは配列では使用不可
     * - 作成後に名前を設定する手段が必要
     * 
     * zombieHorde関数での使用：
     * ```cpp
     * Zombie* horde = new Zombie[N];  // 全て "Unknown"
     * for (int i = 0; i < N; i++) {
     *     horde[i].setName(name);     // 指定した名前に変更
     * }
     * ```
     */
    
    /*
     * 【実装の設計判断】
     * 
     * シンプルな代入を選択：
     * - 複雑な検証やログ出力なし
     * - 高速な実行（配列の全要素で呼ばれるため）
     * - 使いやすさ重視
     * 
     * 代替案との比較：
     * 
     * 案1（この実装）：シンプルな代入
     * ```cpp
     * void setName(std::string name) {
     *     this->_name = name;
     * }
     * ```
     * 
     * 案2：ログ付き
     * ```cpp
     * void setName(std::string name) {
     *     std::cout << "Renaming " << _name << " to " << name << std::endl;
     *     this->_name = name;
     * }
     * ```
     * → 配列で使うとログが大量に出力される
     * 
     * 案3：検証付き
     * ```cpp
     * bool setName(std::string name) {
     *     if (name.empty()) return false;
     *     this->_name = name;
     *     return true;
     * }
     * ```  
     * → エラーハンドリングが複雑になる
     */
    this->_name = name;
    
    /*
     * 【代入演算子の動作】
     * 
     * std::string の代入：
     * - 既存の _name の内容を新しい name で置き換え
     * - メモリ管理は std::string が自動で行う
     * - 古い内容は自動的に解放される
     * 
     * 配列での連続呼び出し：
     * - 各要素で独立して代入が実行される
     * - horde[0]._name = name;
     * - horde[1]._name = name;
     * - ...
     * - 結果として全要素が同じ名前になる
     */
    
    /*
     * 【メモリ効率の考慮】
     * 
     * 値渡し（std::string name）の影響：
     * - 呼び出し時に引数がコピーされる
     * - 代入時にさらにコピーが発生
     * - 計2回のコピー処理
     * 
     * 最適化案（const参照）：
     * ```cpp
     * void setName(const std::string& name) {
     *     this->_name = name;  // 1回のコピーのみ
     * }
     * ```
     * 
     * 学習段階では値渡しで十分：
     * - 理解しやすい
     * - 安全（元の値が変更されない）
     * - パフォーマンス差は微小
     */
}

/*
 * ====================================================================
 * ex01 実装全体の学習ポイント
 * ====================================================================
 * 
 * 【理解すべき核心概念】
 * 
 * 1. 配列とオブジェクト初期化の制約
 *    - C++98 での配列初期化の限界
 *    - デフォルトコンストラクタの必要性
 *    - 作成後の状態変更パターン
 * 
 * 2. メモリ管理の責任分担
 *    - zombieHorde(): 作成と初期化
 *    - 呼び出し元: 使用と解放
 *    - RAII による自動リソース管理
 * 
 * 3. オブジェクトの独立性
 *    - 配列の各要素は独立したオブジェクト
 *    - 各オブジェクトが独自の this ポインタ
 *    - 各オブジェクトが独自のメンバ変数
 * 
 * 【実装での注意点】
 * 
 * 1. 効率性
 *    - 初期化リストの使用
 *    - 不要なログ出力の回避
 *    - 適切なデータ型の選択
 * 
 * 2. 安全性
 *    - this ポインタの適切な使用
 *    - メモリ管理の自動化
 *    - 例外安全性（基本保証）
 * 
 * 3. 保守性
 *    - 一貫したコーディングスタイル
 *    - 明確な責任分担
 *    - 拡張可能な設計
 */

/*
 * ====================================================================
 * デバッグとテストの指針
 * ====================================================================
 * 
 * 【期待される動作パターン】
 * 
 * zombieHorde(3, "Walker") の完全な実行例：
 * 
 * 1. 配列作成（new Zombie[3]）:
 *    "Zombie Unknown created"  ← horde[0] デフォルトコンストラクタ
 *    "Zombie Unknown created"  ← horde[1] デフォルトコンストラクタ
 *    "Zombie Unknown created"  ← horde[2] デフォルトコンストラクタ
 * 
 * 2. 名前設定（setName ループ）:
 *    （ログ出力なし）
 *    horde[0]._name: "Unknown" → "Walker"
 *    horde[1]._name: "Unknown" → "Walker"  
 *    horde[2]._name: "Unknown" → "Walker"
 * 
 * 3. 使用（announce 呼び出し）:
 *    "Walker: BraiiiiiiinnnzzzZ..."  ← horde[0].announce()
 *    "Walker: BraiiiiiiinnnzzzZ..."  ← horde[1].announce()
 *    "Walker: BraiiiiiiinnnzzzZ..."  ← horde[2].announce()
 * 
 * 4. 解放（delete[] horde）:
 *    "Zombie Walker destroyed"  ← horde[?] デストラクタ（順序は実装依存）
 *    "Zombie Walker destroyed"  ← horde[?] デストラクタ
 *    "Zombie Walker destroyed"  ← horde[?] デストラクタ
 * 
 * 【確認項目】
 * - "created" と "destroyed" の数が一致
 * - "Unknown" → 指定名への変更が正常
 * - announce で正しい名前が出力される
 * - メモリリークが発生しない
 */