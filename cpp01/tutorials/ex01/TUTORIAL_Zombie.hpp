/*
 * ====================================================================
 * CPP01 ex01: Moar brainz! - Zombie クラスヘッダー解説版
 * ====================================================================
 * 
 * 【学習目標】
 * - ex00からの発展：配列対応クラス設計
 * - デフォルトコンストラクタの重要性（配列初期化）
 * - setName()メソッドの実用性
 * - 動的配列とオブジェクト初期化の関係
 * 
 * 【ex00からの変更点】
 * - 新機能なし、既存機能の活用方法を学習
 * - デフォルトコンストラクタが配列で必須になる理由を理解
 * - zombieHorde()関数との連携設計
 * 
 * 【重要概念】
 * - 配列初期化時のコンストラクタ制約
 * - オブジェクト作成後の状態変更パターン
 * - 複数オブジェクト管理の基礎
 */

#ifndef ZOMBIE_HPP
#define ZOMBIE_HPP

// 【解説】必要なライブラリのインクルード
#include <string>     // std::string を使用するため
#include <iostream>   // std::cout, std::endl を使用するため

/*
 * ====================================================================
 * Zombieクラス設計解説（ex01向け拡張説明）
 * ====================================================================
 * 
 * 【ex01での使用パターン】
 * 
 * ex00: 単一オブジェクトの個別作成・管理
 * ```cpp
 * Zombie* zombie = newZombie("Alice");  // 引数付きコンストラクタ
 * zombie->announce();
 * delete zombie;
 * ```
 * 
 * ex01: 複数オブジェクトの配列作成・一括管理
 * ```cpp
 * Zombie* horde = zombieHorde(5, "Walker");  // デフォルト→setName
 * for (int i = 0; i < 5; i++) {
 *     horde[i].announce();
 * }
 * delete[] horde;
 * ```
 * 
 * 【設計上の重要な判断】
 * 
 * 1. なぜ両方のコンストラクタが必要なのか？
 *    - デフォルト: 配列初期化で必須（new Zombie[N]）
 *    - 引数付き: 個別作成で便利（newZombie()）
 * 
 * 2. なぜsetName()が必要なのか？
 *    - 配列では引数付きコンストラクタが使えない
 *    - 作成後に名前を設定する仕組みが必要
 * 
 * 3. 同じクラスで異なる初期化パターンに対応
 *    - 柔軟性: 様々な作成方法をサポート
 *    - 一貫性: どの方法でも最終的に同じ機能を提供
 */
class Zombie {
private:
    /*
     * 【メンバ変数】
     * std::string _name;
     * 
     * ex01での重要性：
     * - デフォルトコンストラクタで "Unknown" に初期化
     * - setName() で後から変更可能
     * - 配列の全要素で同じ名前になる（通常は）
     * 
     * 【配列使用時の状態変化】
     * 1. new Zombie[N] → _name = "Unknown" (N個全て)
     * 2. setName(name) → _name = name (ループで各要素)
     * 3. announce() → name + メッセージ を出力
     */
    std::string _name;

public:
    /*
     * ====================================================================
     * コンストラクタ群の解説
     * ====================================================================
     */
    
    /*
     * 【デフォルトコンストラクタ】
     * Zombie();
     * 
     * ex01での重要性が格段に上がる理由：
     * 
     * 配列初期化の制約：
     * - new Zombie[N] は各要素をデフォルトコンストラクタで初期化
     * - 引数付きコンストラクタは配列初期化では使用不可
     * - デフォルトコンストラクタがないとコンパイルエラー
     * 
     * 実装の期待動作：
     * ```cpp
     * Zombie::Zombie() : _name("Unknown") {
     *     std::cout << "Zombie " << _name << " created" << std::endl;
     * }
     * ```
     * 
     * 配列作成時の出力例（N=3の場合）：
     * - "Zombie Unknown created"  ← 1個目
     * - "Zombie Unknown created"  ← 2個目  
     * - "Zombie Unknown created"  ← 3個目
     */
    Zombie(void);
    
    /*
     * 【引数付きコンストラクタ】
     * Zombie(std::string name);
     * 
     * ex01でも重要だが使用場面が限定される：
     * 
     * 使用場面：
     * - 単体テスト時の個別Zombie作成
     * - zombieHorde()以外での作成
     * - ex00の newZombie() との互換性維持
     * 
     * 配列では使用不可：
     * - new Zombie[N](name) ← コンパイルエラー
     * - C++98では配列要素に引数を渡せない
     * 
     * 実装の期待動作：
     * ```cpp
     * Zombie::Zombie(std::string name) : _name(name) {
     *     std::cout << "Zombie " << _name << " created" << std::endl;
     * }
     * ```
     */
    Zombie(std::string name);
    
    /*
     * 【デストラクタ】
     * ~Zombie();
     * 
     * ex01での重要性：
     * - 配列解放時（delete[] horde）に全要素で呼ばれる
     * - メモリリーク検出の重要な指標
     * - "created" と "destroyed" の数が一致する必要
     * 
     * 配列削除時の出力例（N=3, name="Walker"の場合）：
     * - "Zombie Walker destroyed"  ← horde[0]
     * - "Zombie Walker destroyed"  ← horde[1]
     * - "Zombie Walker destroyed"  ← horde[2]
     * 
     * 実装の期待動作：
     * ```cpp
     * Zombie::~Zombie() {
     *     std::cout << "Zombie " << _name << " destroyed" << std::endl;
     * }
     * ```
     */
    ~Zombie(void);
    
    /*
     * ====================================================================
     * メンバ関数群の解説
     * ====================================================================
     */
    
    /*
     * 【announce関数】
     * void announce(void);
     * 
     * ex01での使用パターン：
     * - 配列の各要素で呼び出し（ループ内）
     * - 全て同じ名前だが、各オブジェクトが個別に動作
     * 
     * 典型的な使用例：
     * ```cpp
     * for (int i = 0; i < hordeSize; i++) {
     *     horde[i].announce();  // i番目のZombieが発声
     * }
     * ```
     * 
     * 期待される出力（name="Walker"の場合）：
     * - "Walker: BraiiiiiiinnnzzzZ..."
     * - "Walker: BraiiiiiiinnnzzzZ..."
     * - ...（配列のサイズ分繰り返し）
     */
    void announce(void);
    
    /*
     * 【setName関数】
     * void setName(std::string name);
     * 
     * ex01で新たに重要になる関数：
     * 
     * 必要性の理由：
     * - 配列初期化では引数付きコンストラクタが使えない
     * - デフォルトコンストラクタで作成後、名前を設定する必要
     * - zombieHorde()関数の核となる機能
     * 
     * zombieHorde()での使用パターン：
     * ```cpp
     * Zombie* horde = new Zombie[N];  // 全て "Unknown"
     * for (int i = 0; i < N; i++) {
     *     horde[i].setName(name);     // 全て指定した名前に変更
     * }
     * ```
     * 
     * 設計の柔軟性：
     * - 個別に異なる名前も設定可能
     * - 作成後の名前変更も可能
     * - デバッグ時の識別にも活用可能
     * 
     * 実装の期待動作：
     * ```cpp
     * void Zombie::setName(std::string name) {
     *     this->_name = name;  // シンプルな代入
     *     // 通常はログ出力なし（内部処理として）
     * }
     * ```
     */
    void setName(std::string name);
};

/*
 * ====================================================================
 * zombieHorde関数宣言の解説
 * ====================================================================
 */

/*
 * 【zombieHorde関数】
 * Zombie* zombieHorde(int N, std::string name);
 * 
 * ex01の中心となる関数：
 * 
 * 機能：
 * - N個のZombieオブジェクトを持つ動的配列を作成
 * - 全要素に指定した名前を設定
 * - 配列の先頭ポインタを返却
 * 
 * 実装上の課題：
 * 1. 動的配列の確保（new Zombie[N]）
 * 2. エラーハンドリング（N <= 0の場合）
 * 3. 各要素の初期化（デフォルト→setName）
 * 4. メモリ管理責任の移譲（呼び出し元がdelete[]）
 * 
 * 呼び出し例：
 * ```cpp
 * Zombie* horde = zombieHorde(5, "Walker");
 * // ... horde[0] から horde[4] まで使用 ...
 * delete[] horde;  // 必須：配列の解放
 * ```
 * 
 * エラーケース処理：
 * ```cpp
 * Zombie* invalid = zombieHorde(0, "Test");  // NULL が返る
 * if (!invalid) {
 *     // エラー処理
 * }
 * ```
 * 
 * 【設計判断の理由】
 * 
 * なぜ配列で返すのか？
 * - C++98 では std::vector がまだ一般的でない
 * - 生のポインタ操作を学習する必要
 * - メモリ管理の責任を明確にする教育目的
 * 
 * なぜ全て同じ名前なのか？
 * - ホード（群れ）としての一体感
 * - 実装の簡素化（学習段階として適切）
 * - 必要に応じて個別設定も可能（setName使用）
 */
Zombie* zombieHorde(int N, std::string name);

#endif

/*
 * ====================================================================
 * 学習のポイントと確認事項
 * ====================================================================
 * 
 * 【理解すべき概念】
 * 1. デフォルトコンストラクタの必要性
 *    - 配列初期化での制約を理解
 *    - C++98 の限界と解決策を学習
 * 
 * 2. オブジェクトの状態変更パターン
 *    - 作成時の初期状態（"Unknown"）
 *    - 作成後の状態変更（setName）
 *    - 最終的な使用状態（announce）
 * 
 * 3. メモリ管理の責任分担
 *    - zombieHorde(): 作成と初期化
 *    - 呼び出し元: 使用と解放
 *    - new[] と delete[] の対応
 * 
 * 【実装で注意すべき点】
 * 1. エラーハンドリング
 *    - 無効なサイズ（N <= 0）の処理
 *    - NULLポインタの適切な返却
 * 
 * 2. 初期化の順序
 *    - new Zombie[N] でデフォルト作成
 *    - ループでsetName()呼び出し
 *    - 順序を間違えないように注意
 * 
 * 3. メモリリーク防止
 *    - created と destroyed のログが一致
 *    - delete[] の実行確認
 * 
 * 【テスト項目】
 * □ 正常なサイズでの配列作成
 * □ エラーケース（N=0, N=-1）の処理
 * □ 作成されたオブジェクトの動作確認
 * □ メモリ解放の確認
 * □ 複数回実行でのメモリリーク確認
 * 
 * 【次のステップ】
 * この実装を理解したら：
 * 1. 配列とポインタの関係をより深く学習（ex02）
 * 2. 参照の概念と使い分け（ex02） 
 * 3. より複雑なメモリ管理パターン（ex03以降）
 */

/*
 * ====================================================================
 * よくある間違いと解決策
 * ====================================================================
 * 
 * 【間違い1】デフォルトコンストラクタなし
 * ```cpp
 * class Zombie {
 * public:
 *     Zombie(std::string name);  // これだけだとエラー
 * };
 * // new Zombie[N] でコンパイルエラー
 * ```
 * 解決策：デフォルトコンストラクタを必ず定義
 * 
 * 【間違い2】delete と delete[] の混同
 * ```cpp
 * Zombie* horde = new Zombie[5];
 * delete horde;  // 危険！未定義動作
 * ```
 * 解決策：new[] には必ず delete[] を使用
 * 
 * 【間違い3】NULLポインタの未チェック
 * ```cpp
 * Zombie* horde = zombieHorde(0, "Test");
 * horde[0].announce();  // クラッシュ！
 * ```
 * 解決策：使用前にNULLチェックを実装
 * 
 * 【間違い4】配列サイズの管理忘れ
 * ```cpp
 * Zombie* horde = zombieHorde(5, "Test");
 * for (int i = 0; i < 10; i++) {  // 範囲外アクセス！
 *     horde[i].announce();
 * }
 * ```
 * 解決策：配列サイズを正確に管理・使用
 */