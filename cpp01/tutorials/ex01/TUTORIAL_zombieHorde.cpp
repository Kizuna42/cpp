/*
 * ====================================================================
 * CPP01 ex01: zombieHorde 関数実装解説版
 * ====================================================================
 * 
 * この関数は動的配列確保とオブジェクト初期化の基礎を学ぶ重要な実装です。
 * ex00の知識を発展させ、複数オブジェクトの管理方法を理解します。
 */

#include "Zombie.hpp"

/*
 * ====================================================================
 * zombieHorde関数実装解説
 * ====================================================================
 */
Zombie* zombieHorde(int N, std::string name) {
    /*
     * 関数の役割：N個のZombieオブジェクトを持つ動的配列を作成
     * 
     * 【学習目標】
     * 1. 動的配列の確保方法（new[]）
     * 2. 配列要素の初期化パターン
     * 3. エラーハンドリングの基本
     * 4. デフォルトコンストラクタの重要性
     * 5. 配列とポインタの関係
     * 
     * 【ex00からの発展】
     * ex00: 単一オブジェクトの動的確保
     * ex01: 複数オブジェクトの動的確保（配列）
     */
    
    /*
     * ====================================================================
     * エラーハンドリング: 無効なサイズのチェック
     * ====================================================================
     */
    if (N <= 0) {
        /*
         * なぜこのチェックが必要なのか？
         * 
         * 1. 論理的整合性
         *    - 0個以下のゾンビホードは意味がない
         *    - 負の数の配列は確保できない
         * 
         * 2. メモリ安全性
         *    - new Zombie[0] は未定義動作の可能性
         *    - new Zombie[-1] は確実にエラー
         * 
         * 3. 使いやすさ
         *    - 呼び出し元に明確なエラーメッセージを提供
         *    - NULLを返すことで失敗を明示
         */
        std::cout << "Error: Invalid horde size" << std::endl;
        
        /*
         * NULL vs nullptr の選択
         * 
         * C++98時代の実装なので NULL を使用
         * - NULL: C互換、実際は0または(void*)0のマクロ
         * - nullptr: C++11以降、型安全なnullポインタリテラル
         * 
         * 学習段階では NULL で十分、将来的に nullptr を覚える
         */
        return NULL;
    }
    
    /*
     * ====================================================================
     * 動的配列の確保: new Zombie[N]
     * ====================================================================
     */
    Zombie* horde = new Zombie[N];
    
    /*
     * 【重要】動的配列確保の詳細解説
     * 
     * new Zombie[N] で何が起こるのか？
     * 
     * 1. メモリ確保
     *    - ヒープ上に sizeof(Zombie) * N バイトを確保
     *    - 連続したメモリ領域に N個のZombieオブジェクト分のスペース
     * 
     * 2. オブジェクト初期化
     *    - 各配列要素に対してデフォルトコンストラクタが呼ばれる
     *    - N回の "Zombie Unknown created" が出力される
     *    - 全て _name = "Unknown" で初期化される
     * 
     * 3. ポインタ取得
     *    - 配列の最初の要素へのポインタが返される
     *    - horde[0], horde[1], ..., horde[N-1] でアクセス可能
     * 
     * 【ex00との違い】
     * ex00: new Zombie(name)     - 単一オブジェクト、引数付きコンストラクタ
     * ex01: new Zombie[N]        - 配列、デフォルトコンストラクタのみ
     */
    
    /*
     * 【なぜデフォルトコンストラクタが必要なのか？】
     * 
     * new Zombie[N] は各要素を以下のように初期化：
     * - Zombie horde[0];  ← デフォルトコンストラクタ呼び出し
     * - Zombie horde[1];  ← デフォルトコンストラクタ呼び出し
     * - ...
     * - Zombie horde[N-1]; ← デフォルトコンストラクタ呼び出し
     * 
     * 引数付きコンストラクタは配列初期化では使えない：
     * - new Zombie[N](name) ← これは構文エラー
     * 
     * だからデフォルトコンストラクタで作成後、setName()で名前設定する
     */
    
    /*
     * ====================================================================
     * 配列要素の初期化ループ
     * ====================================================================
     */
    for (int i = 0; i < N; i++) {
        /*
         * 各要素の名前設定: horde[i].setName(name);
         * 
         * 【配列アクセスの解説】
         * 
         * horde[i] の意味：
         * - horde: Zombie*型のポインタ（配列の先頭を指す）
         * - [i]: i番目の要素にアクセス
         * - horde[i]: i番目のZombieオブジェクト（参照として扱える）
         * 
         * ポインタ演算との関係：
         * - horde[i] は *(horde + i) と同じ意味
         * - horde + i: i個分オフセットしたアドレス
         * - *(horde + i): そのアドレスのオブジェクトにアクセス
         * 
         * 【なぜ . 演算子を使うのか？】
         * - horde[i] はオブジェクトそのもの（参照）
         * - オブジェクト直接アクセスなので . 演算子を使用
         * - ポインタアクセスなら -> 演算子を使用
         */
        horde[i].setName(name);
        
        /*
         * この時点で起こること：
         * 1. horde[i] でi番目のZombieオブジェクトにアクセス
         * 2. setName(name) でそのオブジェクトの_nameを変更
         * 3. "Unknown" → name への変更（ログ出力はなし）
         */
    }
    
    /*
     * 【初期化パターンの比較】
     * 
     * パターン1（この実装）：
     * ```cpp
     * Zombie* horde = new Zombie[N];  // デフォルト作成
     * for (int i = 0; i < N; i++) {
     *     horde[i].setName(name);     // 後から名前設定
     * }
     * ```
     * 
     * パターン2（不可能）：
     * ```cpp
     * Zombie* horde = new Zombie[N](name); // コンパイルエラー
     * ```
     * 
     * パターン3（C++11以降で可能）：
     * ```cpp
     * Zombie* horde = new Zombie[N]{Zombie(name), Zombie(name), ...};
     * ```
     * ただしC++98では使用不可
     */
    
    /*
     * ====================================================================
     * 作成した配列の返却
     * ====================================================================
     */
    return horde;
    
    /*
     * 【重要】メモリ管理の責任移譲
     * 
     * この時点で起こること：
     * 1. 動的に確保したZombie配列のポインタを返す
     * 2. 呼び出し元がこの配列の所有権を得る
     * 3. 呼び出し元が delete[] で解放する責任を負う
     * 
     * 【呼び出し元の責任】
     * ```cpp
     * Zombie* horde = zombieHorde(5, "Walker");
     * // ... horde を使用 ...
     * delete[] horde;  // 必須！配列なので delete[] を使用
     * ```
     * 
     * 【よくある間違い】
     * - delete horde;   ← 間違い！単一オブジェクト用
     * - delete[] horde; ← 正解！配列用
     */
}

/*
 * ====================================================================
 * new[] vs new の使い分け
 * ====================================================================
 * 
 * 【使い分けの基本原則】
 * 
 * 単一オブジェクト:
 * - 確保: new Zombie(name)
 * - 解放: delete zombie
 * 
 * 配列:
 * - 確保: new Zombie[N]
 * - 解放: delete[] horde
 * 
 * 【間違った組み合わせの危険性】
 * 
 * 危険な例1:
 * ```cpp
 * Zombie* horde = new Zombie[5];
 * delete horde;    // 未定義動作！メモリ破壊の可能性
 * ```
 * 
 * 危険な例2:
 * ```cpp
 * Zombie* zombie = new Zombie("Test");
 * delete[] zombie; // 未定義動作！メモリ破壊の可能性
 * ```
 * 
 * 【覚え方】
 * - new と delete は対
 * - new[] と delete[] は対
 * - 絶対に混在させない
 */

/*
 * ====================================================================
 * デバッグとメモリリーク検出
 * ====================================================================
 * 
 * 【期待される出力パターン】
 * 
 * zombieHorde(3, "Walker") を呼んだ場合：
 * 
 * 1. 配列確保時（new Zombie[3]）:
 *    - "Zombie Unknown created"  ← horde[0]
 *    - "Zombie Unknown created"  ← horde[1] 
 *    - "Zombie Unknown created"  ← horde[2]
 * 
 * 2. 名前設定時（setNameループ）:
 *    - ログ出力なし（setNameは内部で名前を変更するだけ）
 * 
 * 3. 使用時（各要素のannounce）:
 *    - "Walker: BraiiiiiiinnnzzzZ..."  ← horde[0]
 *    - "Walker: BraiiiiiiinnnzzzZ..."  ← horde[1]
 *    - "Walker: BraiiiiiiinnnzzzZ..."  ← horde[2]
 * 
 * 4. 解放時（delete[] horde）:
 *    - "Zombie Walker destroyed"  ← horde[0]
 *    - "Zombie Walker destroyed"  ← horde[1]
 *    - "Zombie Walker destroyed"  ← horde[2]
 * 
 * 【メモリリーク検出】
 * - "created" と "destroyed" の数を比較
 * - 数が一致しない場合はdelete[]忘れの可能性
 */

/*
 * ====================================================================
 * よくある質問と回答
 * ====================================================================
 * 
 * Q: なぜ引数でサイズと名前を分けるのか？
 * A: - サイズ: 配列の大きさ決定に必要
 *    - 名前: 全ゾンビに共通の名前を設定
 *    - 将来的に個別名前設定にも拡張可能
 * 
 * Q: なぜsetName()を使わず、引数付きコンストラクタを使わないのか？
 * A: - new Zombie[N] は各要素をデフォルトコンストラクタで初期化
 *    - 配列確保時に引数付きコンストラクタは指定できない（C++98）
 *    - 後からsetName()で設定するのが標準的なパターン
 * 
 * Q: エラー時にNULL以外を返す方法はあるか？
 * A: - 例外を投げる（throw）
 *    - サイズ0の有効な配列を返す
 *    - しかし学習段階ではNULL返却が分かりやすい
 * 
 * Q: 配列のサイズを後から変更できるか？
 * A: - 不可能。動的配列のサイズは確保時に固定
 *    - サイズ変更にはnew配列作成＋要素コピー＋old配列削除が必要
 *    - std::vector（C++98でも使用可能）なら動的サイズ変更可能
 */

/*
 * ====================================================================
 * 学習確認チェックリスト
 * ====================================================================
 * 
 * □ new[] と delete[] の対応関係を理解している
 * □ 配列アクセス horde[i] の意味を理解している
 * □ デフォルトコンストラクタが配列で使われる理由を理解している
 * □ エラーハンドリングでNULLを返す理由を理解している
 * □ メモリ管理の責任が呼び出し元にあることを理解している
 * 
 * 【実習課題】
 * 1. delete[] を忘れてメモリリークを体験する
 * 2. 異なるサイズの配列を作成して動作確認する
 * 3. エラーケース（N=0, N=-1）をテストする
 * 4. 配列の各要素に異なる名前を設定してみる
 */

/*
 * ====================================================================
 * 次のステップ
 * ====================================================================
 * 
 * この実装を理解したら次は：
 * 1. main.cpp での使用例とテストケース
 * 2. 配列とポインタの関係をより深く学習
 * 3. メモリリーク検出ツールでの検証
 * 4. ex02 でポインタと参照の詳細学習
 */