/*
 * ====================================================================
 * CPP01 ex00: BraiiiiiiinnnzzzZ - Zombie クラス実装解説版
 * ====================================================================
 * 
 * このファイルではZombieクラスの具体的な実装を学習します。
 * 各関数の実装がなぜこのようになっているのかを詳しく解説します。
 */

#include "Zombie.hpp"

/*
 * ====================================================================
 * デフォルトコンストラクタ実装解説
 * ====================================================================
 */
Zombie::Zombie(void) : _name("Unknown") {
    /*
     * 初期化リスト解説： : _name("Unknown")
     * 
     * なぜ初期化リストを使うのか？
     * 1. 効率性：メンバ変数を初期化時に直接設定（代入ではない）
     * 2. const メンバ変数や参照メンバがある場合は必須
     * 3. C++の推奨される初期化方法
     * 
     * 代替実装（推奨されない）：
     * Zombie::Zombie(void) {
     *     _name = "Unknown";  // これは代入、初期化ではない
     * }
     * 
     * なぜ "Unknown" を初期値にするのか？
     * - デバッグ時に未初期化オブジェクトを特定しやすい
     * - 空文字列よりもわかりやすい
     * - 後から setName() で変更可能
     */
    
    /*
     * 作成ログの出力
     * 
     * なぜログを出力するのか？
     * 1. オブジェクトの生成を視覚的に確認
     * 2. デバッグ時にオブジェクトの生存期間を追跡
     * 3. メモリリークの発見に役立つ
     * 
     * this->_name の解説：
     * - this: 現在のオブジェクトへのポインタ
     * - this-> は省略可能だが、明示性のため記述
     * - _name だけでも同じ意味
     */
    std::cout << "Zombie " << this->_name << " created" << std::endl;
    
    /*
     * 【学習ポイント】
     * このコンストラクタが呼ばれるタイミング：
     * - Zombie zombie;          // スタック上
     * - new Zombie();           // ヒープ上
     * - Zombie zombies[10];     // 配列の各要素
     */
}

/*
 * ====================================================================
 * 引数付きコンストラクタ実装解説
 * ====================================================================
 */
Zombie::Zombie(std::string name) : _name(name) {
    /*
     * 引数付き初期化リスト解説： : _name(name)
     * 
     * パラメータ name と メンバ変数 _name の区別：
     * - name: 関数のパラメータ
     * - _name: クラスのメンバ変数
     * - 初期化リストでは _name(name) で「メンバ変数 _name を パラメータ name で初期化」
     * 
     * なぜ std::string を値渡しにするのか？
     * 1. C++98 時代の標準的な方法
     * 2. 呼び出し元の文字列をコピーして安全に保存
     * 3. 後のC++では const std::string& が推奨される場合もある
     */
    
    /*
     * 同じログ出力処理
     * 
     * なぜ2つのコンストラクタで同じ処理をするのか？
     * - DRY原則に反するが、この場合は許容される
     * - 学習目的では明示的に書く方がわかりやすい
     * - 実際のプロジェクトではヘルパー関数を使うことも
     */
    std::cout << "Zombie " << this->_name << " created" << std::endl;
    
    /*
     * 【学習ポイント】
     * このコンストラクタが呼ばれるタイミング：
     * - Zombie zombie("Alice");     // スタック上、名前指定
     * - new Zombie("Bob");          // ヒープ上、名前指定
     */
}

/*
 * ====================================================================
 * デストラクタ実装解説
 * ====================================================================
 */
Zombie::~Zombie(void) {
    /*
     * デストラクタの役割：
     * 1. オブジェクト破棄時のクリーンアップ処理
     * 2. この例では主にログ出力（学習目的）
     * 3. 実際のプロジェクトではメモリ解放、ファイルクローズなど
     * 
     * なぜログを出力するのか？
     * - オブジェクトの破棄タイミングを確認
     * - メモリリークの検出支援
     * - プログラムの動作フローの理解
     */
    std::cout << "Zombie " << this->_name << " destroyed" << std::endl;
    
    /*
     * 【重要】デストラクタが呼ばれるタイミング：
     * 
     * スタック変数の場合：
     * {
     *     Zombie zombie("Alice");
     * }  // ← ここで自動的にデストラクタが呼ばれる
     * 
     * ヒープ変数の場合：
     * Zombie* zombie = new Zombie("Bob");
     * delete zombie;  // ← ここで明示的にデストラクタを呼ぶ
     * 
     * 【よくある間違い】
     * delete を忘れるとデストラクタが呼ばれずメモリリーク発生
     */
}

/*
 * ====================================================================
 * announce関数実装解説
 * ====================================================================
 */
void Zombie::announce(void) {
    /*
     * Zombieの主要機能：自己紹介
     * 
     * なぜこの関数が必要なのか？
     * 1. オブジェクトの主要な動作を表現
     * 2. オブジェクトが「生きている」ことの証明
     * 3. 名前が正しく設定されているかの確認
     * 
     * 出力形式： "名前: BraiiiiiiinnnzzzZ..."
     * - 42スクールの課題仕様に従った形式
     * - ゾンビらしい表現
     */
    std::cout << this->_name << ": BraiiiiiiinnnzzzZ..." << std::endl;
    
    /*
     * 【学習ポイント】
     * - this->_name でメンバ変数にアクセス
     * - public 関数なので外部から呼び出し可能
     * - オブジェクトの状態（_name）を使用した処理の例
     */
}

/*
 * ====================================================================
 * setName関数実装解説
 * ====================================================================
 */
void Zombie::setName(std::string name) {
    /*
     * メンバ変数の更新処理
     * 
     * なぜこの関数が必要なのか？
     * 1. _name は private なので直接変更できない
     * 2. デフォルトコンストラクタで作成したオブジェクトに名前を設定
     * 3. 実行時に名前を変更する必要がある場合
     * 
     * 実装の詳細：
     * - 単純な代入処理
     * - エラーチェックは特に行わない（学習段階では簡略化）
     * - 実際のプロジェクトでは入力検証を行うことが多い
     */
    this->_name = name;
    
    /*
     * 【設計判断】
     * なぜログを出力しないのか？
     * - setName は「設定」処理で「生成」ではない
     * - 頻繁に呼ばれる可能性があるためログが多くなりすぎる
     * - デバッグ時は必要に応じて追加すればよい
     */
    
    /*
     * 【使用例】
     * Zombie zombie;           // "Unknown" で作成
     * zombie.setName("Charlie"); // 名前を "Charlie" に変更
     * zombie.announce();       // "Charlie: BraiiiiiiinnnzzzZ..." が出力される
     */
}

/*
 * ====================================================================
 * 実装全体の学習ポイント
 * ====================================================================
 * 
 * 【このファイルから学ぶべきこと】
 * 
 * 1. 初期化リストの重要性と使用方法
 *    - 効率的なメンバ変数の初期化
 *    - const メンバや参照メンバの初期化方法
 * 
 * 2. コンストラクタ・デストラクタの実装パターン
 *    - ログ出力による動作確認
 *    - オブジェクトの生存期間の管理
 * 
 * 3. メンバ関数の実装方法
 *    - this ポインタの使用方法
 *    - メンバ変数へのアクセス方法
 * 
 * 4. カプセル化の実践
 *    - private メンバへの制御されたアクセス
 *    - setter 関数の実装パターン
 * 
 * 【次のステップ】
 * - newZombie.cpp と randomChump.cpp の実装
 * - main.cpp での使用例
 * - メモリリークの検出実習
 * 
 * 【実習課題】
 * 1. setName で空文字列チェックを追加してみる
 * 2. announce で出力形式を変更してみる
 * 3. デストラクタでより詳しい情報を出力してみる
 */

/*
 * ====================================================================
 * デバッグのヒント
 * ====================================================================
 * 
 * 【よくある問題と解決方法】
 * 
 * 1. オブジェクトが作成されない
 *    → コンストラクタのログが出力されるか確認
 * 
 * 2. オブジェクトが削除されない
 *    → デストラクタのログが出力されるか確認
 *    → delete を忘れていないか確認
 * 
 * 3. 名前が正しく設定されない
 *    → setName が呼ばれているか確認
 *    → 初期化リストが正しく動作しているか確認
 * 
 * 【メモリリーク検出】
 * - 「created」と「destroyed」のログ数が一致するかチェック
 * - valgrind（Linux）や AddressSanitizer で検証
 */