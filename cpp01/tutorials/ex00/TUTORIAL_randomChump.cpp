/*
 * ====================================================================
 * CPP01 ex00: randomChump 関数実装解説版
 * ====================================================================
 * 
 * この関数はスタックメモリ管理の基礎とRAII原則を学ぶための実装です。
 * newZombie との対比で、メモリ管理の違いを理解することが重要です。
 */

#include "Zombie.hpp"

/*
 * ====================================================================
 * randomChump関数実装解説
 * ====================================================================
 */
void randomChump(std::string name) {
    /*
     * 関数の役割：一時的なZombieを作成し、即座に使用する
     * 
     * 【設計意図】
     * なぜこの関数が必要なのか？
     * 
     * 1. スタックメモリ管理の学習
     *    - 自動変数（スタック変数）の概念理解
     *    - RAII（Resource Acquisition Is Initialization）の実践
     *    - 自動的なメモリ管理の恩恵を体験
     * 
     * 2. newZombie との比較学習
     *    - ヒープ vs スタックの使い分け
     *    - メモリ管理の責任の違い
     *    - 生存期間の違いの理解
     * 
     * 3. 一時的な処理のパターン
     *    - 「作成→使用→自動削除」の流れ
     *    - 長期保存が不要な場合の適切な実装
     */
    
    /*
     * スタック変数の作成： Zombie zombie(name);
     * 
     * 何が起こっているのか？
     * 1. 関数のスタックフレーム上にZombieオブジェクト分のメモリを確保
     * 2. 確保されたメモリ上でZombie(name)コンストラクタを実行
     * 3. 変数名 "zombie" でそのオブジェクトにアクセス可能になる
     * 
     * newZombie との違い：
     * - new Zombie(name): ヒープメモリに作成、手動削除が必要
     * - Zombie zombie(name): スタックメモリに作成、自動削除
     */
    Zombie zombie(name);
    
    /*
     * 【重要】なぜ引数付きコンストラクタを直接使うのか？
     * 
     * 効率的な実装：
     * ```cpp
     * Zombie zombie(name);  // 作成と同時に初期化
     * ```
     * 
     * 非効率な実装（避けるべき）：
     * ```cpp
     * Zombie zombie;        // デフォルト作成（"Unknown"で初期化）
     * zombie.setName(name); // 後から名前を設定（二度手間）
     * ```
     * 
     * 引数付きコンストラクタの利点：
     * - 一度の処理で初期化完了
     * - 未初期化状態を避けられる
     * - より明確な意図の表現
     */
    
    /*
     * Zombieの動作実行： zombie.announce();
     * 
     * なぜここで announce() を呼ぶのか？
     * 1. オブジェクトが正しく作成されたことの確認
     * 2. この関数の目的（一時的な使用）を明確にする
     * 3. 課題の要求仕様を満たす
     * 
     * オブジェクトの使用パターン：
     * - 作成されたオブジェクトのメソッドを呼び出し
     * - 戻り値を必要としない一時的な処理
     */
    zombie.announce();
    
    /*
     * 【自動削除】関数終了時の処理
     * 
     * この関数が終了すると何が起こるのか？
     * 1. スタックフレームが破棄される
     * 2. zombie オブジェクトのデストラクタが自動的に呼ばれる
     * 3. "Zombie [name] destroyed" が出力される
     * 4. メモリが自動的に解放される
     * 
     * プログラマーがすること：
     * - 何もしない！
     * - delete の呼び出し不要
     * - メモリリークの心配不要
     * 
     * これがRAII（Resource Acquisition Is Initialization）の恩恵
     */
}

/*
 * ====================================================================
 * newZombie との詳細比較
 * ====================================================================
 * 
 * 【メモリ確保場所】
 * newZombie:    ヒープメモリ（動的確保）
 * randomChump:  スタックメモリ（自動確保）
 * 
 * 【生存期間】
 * newZombie:    呼び出し元が delete するまで
 * randomChump:  関数終了まで
 * 
 * 【メモリ管理責任】
 * newZombie:    呼び出し元が delete 必要
 * randomChump:  自動管理、プログラマーの作業不要
 * 
 * 【使用場面】
 * newZombie:    長期間使用、複数の場所で共有
 * randomChump:  一時的使用、その場限りの処理
 * 
 * 【エラーリスク】
 * newZombie:    メモリリークのリスク高
 * randomChump:  メモリリークのリスク低
 * 
 * 【パフォーマンス】
 * newZombie:    ヒープ確保のオーバーヘッドあり
 * randomChump:  スタック確保、高速
 */

/*
 * ====================================================================
 * 実際の使用例比較
 * ====================================================================
 * 
 * 【randomChump の使用例】
 * ```cpp
 * randomChump("Alice");  // 一時的にAliceを作成・使用・削除
 * randomChump("Bob");    // 一時的にBobを作成・使用・削除
 * // メモリ管理の心配なし！
 * ```
 * 
 * 【newZombie の使用例】
 * ```cpp
 * Zombie* alice = newZombie("Alice");  // Aliceを作成
 * alice->announce();                   // 使用
 * delete alice;                        // 手動で削除が必要
 * 
 * Zombie* bob = newZombie("Bob");      // Bobを作成
 * bob->announce();                     // 使用
 * delete bob;                          // 手動で削除が必要
 * ```
 * 
 * 【どちらを選ぶべきか？】
 * - 一時的な使用 → randomChump パターン
 * - 長期的な使用 → newZombie パターン
 * - 迷ったら randomChump パターンを選ぶ（安全）
 */

/*
 * ====================================================================
 * RAII原則の実践例
 * ====================================================================
 * 
 * RAII (Resource Acquisition Is Initialization) とは：
 * - リソースの取得と初期化を同時に行う
 * - オブジェクトの生存期間でリソースの生存期間を管理
 * - デストラクタでリソースを確実に解放
 * 
 * この関数でのRAIIの実践：
 * 1. Zombie zombie(name); ← リソース（オブジェクト）の取得と初期化
 * 2. zombie.announce();   ← リソースの使用
 * 3. 関数終了時           ← デストラクタによる自動的なリソース解放
 * 
 * RAIIの利点：
 * - メモリリークの防止
 * - 例外安全性の向上
 * - プログラマーのミスの減少
 * - コードの簡潔性
 */

/*
 * ====================================================================
 * よくある誤解と正しい理解
 * ====================================================================
 * 
 * 【誤解1】「スタック変数は性能が悪い」
 * 正解：スタック変数の方が高速。ヒープ確保の方がオーバーヘッドが大きい。
 * 
 * 【誤解2】「new を使った方が高機能」
 * 正解：使用目的による。一時的用途にはスタック変数が適切。
 * 
 * 【誤解3】「randomChump はオブジェクトを返せない」
 * 正解：返すべきではない。返すとダングリングポインタ/参照になる。
 * 
 * 【正しい理解】
 * - スタック変数：高速、自動管理、関数スコープ内のみ
 * - ヒープ変数：柔軟、手動管理、任意の生存期間
 */

/*
 * ====================================================================
 * 学習確認チェックリスト
 * ====================================================================
 * 
 * □ スタック変数とヒープ変数の違いを説明できる
 * □ RAII原則を理解している
 * □ なぜこの関数でポインタを返さないのか説明できる
 * □ デストラクタが呼ばれるタイミングを理解している
 * □ newZombie との使い分けができる
 * 
 * 【実習課題】
 * 1. この関数を複数回呼んで、作成・削除のログを確認する
 * 2. 関数内でzombieを返そうとして、コンパイルエラーを体験する
 * 3. デバッガーでスタックフレームの変化を観察する
 */

/*
 * ====================================================================
 * 次のステップ
 * ====================================================================
 * 
 * この実装を理解したら次は：
 * 1. main.cpp で両方の関数の使用例を学習
 * 2. より複雑なスタック変数の使用（ex01: ZombieHorde）
 * 3. 例外安全性について学習
 * 4. 現代C++でのスマートポインタ（将来の学習）
 */