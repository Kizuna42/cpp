/*
 * ====================================================================
 * CPP01 ex00: BraiiiiiiinnnzzzZ - Zombie クラスヘッダー解説版
 * ====================================================================
 * 
 * 【学習目標】
 * - クラス設計の基本（カプセル化）
 * - コンストラクタ・デストラクタの役割
 * - スタック vs ヒープメモリ管理の基礎
 * - 関数宣言とクラス外関数の組み合わせ
 * 
 * 【重要概念】
 * - RAII: Resource Acquisition Is Initialization
 * - オブジェクトの生存期間管理
 * - メモリ管理の責任分担
 */

#ifndef ZOMBIE_HPP
#define ZOMBIE_HPP

// 【解説】必要なライブラリのインクルード
#include <string>     // std::string を使用するため
#include <iostream>   // std::cout, std::endl を使用するため

/*
 * ====================================================================
 * Zombieクラス設計解説
 * ====================================================================
 * 
 * 【設計判断】なぜこのような設計にしたのか？
 * 
 * 1. カプセル化の実践
 *    - _name をprivateにして外部から直接アクセスを防ぐ
 *    - アンダースコア付きは42スクールの命名規則
 * 
 * 2. コンストラクタのオーバーロード
 *    - デフォルトコンストラクタ: 名前未指定の場合
 *    - 引数付きコンストラクタ: 名前を指定して作成
 * 
 * 3. メンバ関数の責任分担
 *    - announce(): Zombieの基本動作
 *    - setName(): 作成後の名前変更（柔軟性のため）
 */
class Zombie {
private:
    /*
     * 【メンバ変数】
     * std::string _name;
     * 
     * なぜstd::stringを使うのか？
     * - 自動メモリ管理（RAIIの恩恵）
     * - 文字列操作が簡単
     * - char*と比較してメモリリークのリスクが低い
     * 
     * なぜprivateなのか？
     * - カプセル化：外部から直接変更されることを防ぐ
     * - データ整合性の保証
     * - 将来的な実装変更への対応
     */
    std::string _name;

public:
    /*
     * 【コンストラクタ群】
     * なぜ2つのコンストラクタが必要なのか？
     * 
     * 1. デフォルトコンストラクタ Zombie(void)
     *    - 引数なしでオブジェクト作成: Zombie zombie;
     *    - 配列作成時に必要: Zombie zombies[10];
     *    - 一時的なオブジェクト作成時に便利
     * 
     * 2. 引数付きコンストラクタ Zombie(std::string name)
     *    - 初期化時に名前を設定: Zombie zombie("Alice");
     *    - より直感的なオブジェクト作成
     */
    Zombie(void);                    // デフォルトコンストラクタ
    Zombie(std::string name);        // 引数付きコンストラクタ
    
    /*
     * 【デストラクタ】
     * ~Zombie(void);
     * 
     * なぜデストラクタが必要なのか？
     * - オブジェクト破棄時の処理（ログ出力など）
     * - RAIIパターンの実践
     * - メモリリークの防止（この例では主にログ用）
     * 
     * いつ呼ばれるのか？
     * - スタック変数: スコープを出る時
     * - ヒープ変数: delete される時
     */
    ~Zombie(void);                   // デストラクタ
    
    /*
     * 【パブリックメンバ関数】
     * なぜこれらの関数が必要なのか？
     * 
     * 1. announce(): Zombieの基本動作
     *    - オブジェクトの主要機能
     *    - 「このオブジェクトが生きている」ことの証明
     * 
     * 2. setName(): オブジェクト作成後の状態変更
     *    - デフォルトコンストラクタで作成したオブジェクトに名前を設定
     *    - 柔軟性の提供（実行時に名前を決定可能）
     */
    void announce(void);             // Zombie が自己紹介する
    void setName(std::string name);  // 名前を設定する
};

/*
 * ====================================================================
 * クラス外関数宣言解説
 * ====================================================================
 * 
 * なぜクラスの外に関数を定義するのか？
 * 
 * 【設計理念】
 * - ファクトリーパターンの基礎
 * - オブジェクト作成の責任分離
 * - 使用場面に応じた適切な作成方法の提供
 */

/*
 * 【newZombie関数】
 * Zombie* newZombie(std::string name);
 * 
 * 目的：ヒープにZombieオブジェクトを作成
 * 
 * なぜこの関数が必要なのか？
 * - 関数を出た後もオブジェクトが生存する必要がある場合
 * - 呼び出し元がオブジェクトの生存期間を制御したい場合
 * - 動的メモリ確保の練習
 * 
 * 使用例：
 *   Zombie* zombie = newZombie("Alice");
 *   zombie->announce();
 *   delete zombie;  // 忘れずに削除！
 * 
 * 【重要】メモリ管理の責任
 * - この関数で作成したオブジェクトは呼び出し元が削除する責任を持つ
 * - delete を忘れるとメモリリークが発生
 */
Zombie* newZombie(std::string name);

/*
 * 【randomChump関数】
 * void randomChump(std::string name);
 * 
 * 目的：スタックにZombieオブジェクトを作成し即座に使用
 * 
 * なぜこの関数が必要なのか？
 * - 一時的な使用のみで長期保存が不要な場合
 * - 自動的なメモリ管理（スコープアウトで自動削除）
 * - スタック vs ヒープの使い分けの学習
 * 
 * 使用例：
 *   randomChump("Bob");  // 関数内で作成・使用・自動削除
 * 
 * 【重要】メモリ管理の違い
 * - スタック変数：関数終了時に自動的に削除
 * - メモリ管理を気にする必要がない
 * - ただし関数外では使用できない
 */
void randomChump(std::string name);

/*
 * ====================================================================
 * 学習のポイント
 * ====================================================================
 * 
 * 【このヘッダーファイルから学ぶべきこと】
 * 
 * 1. クラス設計の基本
 *    - カプセル化（private/public の使い分け）
 *    - コンストラクタ・デストラクタの役割
 *    - メンバ関数の責任分担
 * 
 * 2. メモリ管理の基礎
 *    - スタック vs ヒープの概念
 *    - オブジェクトの生存期間
 *    - メモリ管理の責任分担
 * 
 * 3. 関数設計の考え方
 *    - クラスメンバ関数 vs 独立関数
 *    - ファクトリーパターンの基礎
 *    - 使用場面に応じた適切な設計
 * 
 * 【次に学ぶべきこと】
 * - 実装ファイル（.cpp）での具体的な実装
 * - main関数での使用例
 * - メモリリークの検出方法
 * 
 * 【よくある間違い】
 * 1. newZombie で作成したオブジェクトの delete 忘れ
 * 2. スタック変数のポインタを関数外で使用
 * 3. デストラクタの呼び出しタイミングの誤解
 */

#endif

/*
 * ====================================================================
 * 学習確認チェックリスト
 * ====================================================================
 * 
 * □ なぜZombieクラスにデフォルトコンストラクタが必要なのか説明できる
 * □ なぜ_nameをprivateにするのか理由を3つ挙げられる
 * □ newZombie と randomChump の使い分けができる
 * □ いつデストラクタが呼ばれるのか説明できる
 * □ メモリリークが起こる場面を具体的に説明できる
 */