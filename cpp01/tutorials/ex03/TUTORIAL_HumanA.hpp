/*
 * ====================================================================
 * CPP01 ex03: Unnecessary violence - HumanA クラスヘッダー解説版
 * ====================================================================
 * 
 * 【学習目標】
 * - 参照メンバ変数の実装と制約
 * - 初期化リストでの参照初期化
 * - 常に有効なリソースを保証する設計
 * - const関数での参照アクセス
 * - 「必須リソース」設計パターン
 * 
 * 【重要概念】
 * - HumanAは「常に武器を持つ戦士」
 * - 参照により武器との強固な結合
 * - NULL武器の不可能性
 * - コンストラクタでの必須初期化
 */

#ifndef HUMANA_HPP
#define HUMANA_HPP

#include "Weapon.hpp"

/*
 * ====================================================================
 * HumanAクラス設計解説
 * ====================================================================
 * 
 * 【設計コンセプト】
 * 
 * HumanA = "Always Armed Human"（常に武装した人間）
 * 
 * 1. 基本設計思想
 *    - 武器は戦士の必須装備
 *    - 素手での戦闘は想定しない
 *    - 武器なしの HumanA は存在しない
 * 
 * 2. 技術的実装方針
 *    - Weapon を参照（&）で保持
 *    - コンストラクタで武器を必須指定
 *    - NULL チェック不要の安全設計
 * 
 * 3. HumanB との設計対比
 *    - HumanA: 参照 → 必須武器
 *    - HumanB: ポインタ → オプション武器
 *    - 異なる設計思想の実証
 * 
 * 【実世界での類例】
 * 
 * この設計パターンは現実でも多用される：
 * - ログガー（必須）vs オプショナルログガー
 * - データベース接続（必須）vs キャッシュ（オプション）
 * - 設定ファイル（必須）vs プラグイン（オプション）
 */
class HumanA {
private:
    /*
     * ====================================================================
     * メンバ変数の設計解説
     * ====================================================================
     */
    
    /*
     * 【名前メンバ】
     * std::string _name;
     * 
     * 戦士の名前を格納：
     * - HumanB と同じ設計（一貫性）
     * - 値型での保持（独立性確保）
     * - 変更可能だが、setter は提供しない（シンプル設計）
     */
    std::string _name;
    
    /*
     * 【武器メンバ - 参照による保持】
     * Weapon& _weapon;
     * 
     * この設計が ex03 の核心：
     * 
     * なぜ参照（&）を選択したのか？
     * 
     * 1. 必須性の表現
     *    - 参照は NULL になれない
     *    - 「武器なし」状態を設計レベルで排除
     *    - コンパイル時に安全性を保証
     * 
     * 2. 初期化の強制
     *    - 参照は宣言時に必ず初期化が必要
     *    - コンストラクタで武器指定を強制
     *    - 未初期化状態の防止
     * 
     * 3. 再代入の不可
     *    - 一度設定した武器を変更不可
     *    - 「専用武器を持つ戦士」の表現
     *    - 意図しない武器変更の防止
     * 
     * 4. 効率性
     *    - 間接参照のオーバーヘッドなし
     *    - ポインタと同等の効率性
     *    - メモリ使用量の最小化
     * 
     * 【参照の制約と利点】
     * 
     * 制約：
     * - 初期化時に武器が必要
     * - 武器の変更不可
     * - NULL チェック不要（利点でもある）
     * 
     * 利点：
     * - 常に有効な武器を保証
     * - シンプルなアクセス（weapon.getType()）
     * - エラー処理の簡素化
     * - 設計意図の明確化
     * 
     * 【HumanB との決定的な違い】
     * 
     * HumanA: Weapon& _weapon
     * - 常に有効な武器
     * - 初期化時に必須
     * - 変更不可
     * 
     * HumanB: Weapon* _weapon
     * - NULL の可能性
     * - 後から設定可能
     * - 変更可能
     */
    Weapon& _weapon;

public:
    /*
     * ====================================================================
     * コンストラクタの設計解説
     * ====================================================================
     */
    
    /*
     * 【引数付きコンストラクタ】
     * HumanA(std::string name, Weapon& weapon);
     * 
     * 参照メンバを持つクラスの必須パターン：
     * 
     * 引数設計の詳細：
     * 
     * 1. std::string name
     *    - 戦士の名前
     *    - 値渡しで安全性確保
     *    - HumanB と同じパターン
     * 
     * 2. Weapon& weapon
     *    - 武器の参照
     *    - 必ず有効な Weapon オブジェクトが必要
     *    - NULL 渡し不可（コンパイルエラー）
     * 
     * なぜデフォルトコンストラクタを提供しないのか？
     * 
     * 1. 参照メンバの制約
     *    - 参照は宣言時に初期化が必要
     *    - デフォルトコンストラクタでは初期化不可
     * 
     * 2. 設計意図の明確化
     *    - 「武器なしの戦士」は想定しない
     *    - 作成時に必ず武器を指定
     * 
     * 3. エラー防止
     *    - 不完全な初期化を防ぐ
     *    - 使用時のエラーを設計時に排除
     * 
     * 使用例：
     * ```cpp
     * Weapon sword("steel sword");
     * HumanA knight("Sir Lancelot", sword);  // 正常
     * 
     * HumanA invalid;                        // コンパイルエラー
     * HumanA nullWeapon("John", NULL);       // コンパイルエラー
     * ```
     * 
     * 実装の期待動作：
     * ```cpp
     * HumanA::HumanA(std::string name, Weapon& weapon) 
     *     : _name(name), _weapon(weapon) {
     *     // 初期化リストで両メンバを初期化
     *     // 特に _weapon は初期化リストでのみ初期化可能
     * }
     * ```
     */
    HumanA(std::string name, Weapon& weapon);
    
    /*
     * 【デストラクタ】
     * ~HumanA(void);
     * 
     * 参照メンバを持つクラスのデストラクタ：
     * 
     * 特別な処理は不要：
     * - _name は std::string（自動破棄）
     * - _weapon は参照（元オブジェクトは破棄されない）
     * - 主にデバッグ用のログ出力
     * 
     * 重要な注意点：
     * - HumanA の破棄時に Weapon は破棄されない
     * - 参照なので所有権はない
     * - Weapon の生存期間は別途管理が必要
     * 
     * 実装の期待動作：
     * ```cpp
     * HumanA::~HumanA() {
     *     // ログ出力のみ
     *     // _weapon は参照なので特別な処理不要
     * }
     * ```
     */
    ~HumanA(void);
    
    /*
     * ====================================================================
     * メンバ関数の設計解説
     * ====================================================================
     */
    
    /*
     * 【attack関数】
     * void attack(void) const;
     * 
     * 戦士の基本動作：武器を使った攻撃
     * 
     * const関数設計の理由：
     * 
     * 1. 論理的const性
     *    - 攻撃はHumanAの状態を変更しない
     *    - 名前も武器も変更されない
     *    - 純粋に情報の出力のみ
     * 
     * 2. 参照メンバでのconst使用
     *    - _weapon.getType() はconst関数
     *    - const HumanA からも呼び出し可能
     *    - 安全なアクセスパターン
     * 
     * 3. インターフェースの一貫性
     *    - HumanB の attack() もconst関数
     *    - 同じシグネチャで統一
     * 
     * 実装での参照アクセス：
     * 
     * ```cpp
     * void HumanA::attack() const {
     *     // 参照による直接アクセス
     *     std::cout << _name << " attacks with their " 
     *               << _weapon.getType() << std::endl;
     * }
     * ```
     * 
     * 【HumanB との攻撃処理の違い】
     * 
     * HumanA（参照）:
     * ```cpp
     * _weapon.getType()  // 直接アクセス、NULLチェック不要
     * ```
     * 
     * HumanB（ポインタ）:
     * ```cpp
     * if (_weapon) {
     *     _weapon->getType()  // 間接アクセス、NULLチェック必要
     * } else {
     *     // 武器なしの処理
     * }
     * ```
     * 
     * HumanA の方がシンプルで安全：
     * - NULLチェック不要
     * - エラー処理不要
     * - 直接的なアクセス
     * - コードの簡潔性
     */
    void attack(void) const;
};

#endif

/*
 * ====================================================================
 * 学習確認チェックリスト
 * ====================================================================
 * 
 * HumanA クラスについて理解すべき項目：
 * 
 * □ 参照メンバ変数の宣言と制約
 * □ 初期化リストでの参照初期化の必要性
 * □ デフォルトコンストラクタが提供されない理由
 * □ NULL安全性の設計による恩恵
 * □ const関数での参照メンバアクセス
 * □ HumanB との設計思想の違い
 * □ 必須リソースパターンの実装
 * □ 参照の生存期間依存性
 * 
 * 【実習課題】
 * 1. 参照初期化を忘れた場合のコンパイルエラーを確認
 * 2. デフォルトコンストラクタを作ろうとした時のエラーを体験
 * 3. const HumanA オブジェクトから attack() を呼び出す
 * 4. Weapon変更時の HumanA の動作確認
 */

/*
 * ====================================================================
 * よくある間違いと対策
 * ====================================================================
 * 
 * 【間違い1】参照の初期化リスト忘れ
 * ```cpp
 * HumanA::HumanA(std::string name, Weapon& weapon) {
 *     _name = name;
 *     _weapon = weapon;  // コンパイルエラー！
 * }
 * ```
 * 対策：参照は初期化リストでのみ初期化可能
 * 
 * 【間違い2】デフォルトコンストラクタの実装試行
 * ```cpp
 * HumanA::HumanA() : _name("Unknown") {
 *     // _weapon の初期化方法がない
 * }
 * ```
 * 対策：参照メンバがある場合は引数付きコンストラクタのみ
 * 
 * 【間違い3】参照の再代入試行
 * ```cpp
 * void HumanA::changeWeapon(Weapon& newWeapon) {
 *     _weapon = newWeapon;  // これは値の代入、参照の変更ではない
 * }
 * ```
 * 理解：参照は常に同じオブジェクトを参照、値のみ変更される
 * 
 * 【間違い4】NULLチェックの実装
 * ```cpp
 * void HumanA::attack() const {
 *     if (&_weapon != NULL) {  // 不要なチェック
 *         // ...
 *     }
 * }
 * ```
 * 対策：参照は常に有効、NULLチェック不要
 */

/*
 * ====================================================================
 * 設計パターンの深掘り
 * ====================================================================
 * 
 * 【必須リソースパターン】
 * 
 * HumanA が実装している設計パターン：
 * 
 * 1. パターンの概要
 *    - オブジェクトが必須リソースに依存
 *    - リソースなしでは意味のないオブジェクト
 *    - 参照による強固な結合
 * 
 * 2. 実装の特徴
 *    - コンストラクタでリソース必須
 *    - NULLになる可能性を排除
 *    - シンプルで安全な使用法
 * 
 * 3. 適用場面
 *    - データベース接続が必須のDAOクラス
 *    - ログ出力が必須のサービスクラス
 *    - 設定ファイルが必須のアプリケーションクラス
 * 
 * 【参照による依存性注入】
 * 
 * HumanA は依存性注入パターンの実装例：
 * 
 * ```cpp
 * // 依存関係（Weapon）を外部から注入
 * Weapon sword("steel sword");
 * HumanA knight("Lancelot", sword);  // 依存性注入
 * ```
 * 
 * 利点：
 * - テストが容易（モックWeaponの注入）
 * - 柔軟な設定（異なるWeaponの注入）
 * - 疎結合の実現（WeaponとHumanAの分離）
 * 
 * 【SOLID原則との関係】
 * 
 * HumanA の設計とSOLID原則：
 * 
 * 1. S - 単一責任原則
 *    - HumanA: 戦士としての行動のみ
 *    - Weapon: 武器としての機能のみ
 * 
 * 2. O - 開放/閉鎖原則
 *    - 新しいWeapon種類に対して開放
 *    - HumanA の実装は変更不要
 * 
 * 3. L - リスコフ置換原則
 *    - 異なるWeaponでも同じインターフェース
 * 
 * 4. I - インターフェース分離原則
 *    - HumanA は Weapon の最小限のインターフェースのみ使用
 * 
 * 5. D - 依存性逆転原則
 *    - HumanA は具体的なWeapon実装に依存しない
 */

/*
 * ====================================================================
 * パフォーマンスとメモリ使用量
 * ====================================================================
 * 
 * 【メモリレイアウト】
 * 
 * HumanA オブジェクトのメモリ構成：
 * ```
 * HumanA オブジェクト
 * ├── _name:   std::string (通常24-32バイト)
 * └── _weapon: 参照 (実装依存、多くの場合追加メモリなし)
 * ```
 * 
 * 【参照のメモリ効率】
 * 
 * 参照の実装について：
 * 1. 最適化時：追加メモリなし（完全に最適化される）
 * 2. デバッグ時：ポインタサイズ（8バイト）程度
 * 3. 実用上：ポインタと同等の効率性
 * 
 * 【アクセス性能】
 * 
 * 参照によるアクセス：
 * ```cpp
 * // 参照アクセス（HumanA）
 * _weapon.getType()  // 直接アクセス
 * 
 * // ポインタアクセス（HumanB）
 * _weapon->getType() // 間接アクセス
 * ```
 * 
 * 最適化後は両者ほぼ同等だが、参照の方が：
 * - NULLチェックのオーバーヘッドなし
 * - より積極的な最適化が可能
 * - キャッシュ効率が若干良い場合がある
 */

/*
 * ====================================================================
 * 実世界での応用例
 * ====================================================================
 * 
 * 【類似設計の実例】
 * 
 * 1. ログガークラス
 * ```cpp
 * class Service {
 * private:
 *     Logger& _logger;  // 必須のログ出力
 * public:
 *     Service(Logger& logger) : _logger(logger) {}
 *     void process() {
 *         _logger.info("Processing...");  // 常に安全
 *     }
 * };
 * ```
 * 
 * 2. データベースアクセスオブジェクト
 * ```cpp
 * class UserDAO {
 * private:
 *     Database& _db;  // 必須のDB接続
 * public:
 *     UserDAO(Database& db) : _db(db) {}
 *     User find(int id) {
 *         return _db.query("SELECT * FROM users WHERE id=?", id);
 *     }
 * };
 * ```
 * 
 * 3. 設定管理クラス
 * ```cpp
 * class Application {
 * private:
 *     Config& _config;  // 必須の設定
 * public:
 *     Application(Config& config) : _config(config) {}
 *     void start() {
 *         int port = _config.getPort();  // 常に取得可能
 *     }
 * };
 * ```
 * 
 * 【選択指針】
 * 
 * 参照を選ぶべき場面：
 * - リソースが必須で、なければ意味がない
 * - リソースの変更が不要
 * - シンプルで安全な設計を重視
 * - NULLチェックのオーバーヘッドを避けたい
 * 
 * ポインタを選ぶべき場面：
 * - リソースがオプショナル
 * - 実行時にリソースを変更する必要
 * - 動的メモリ管理が必要
 * - C言語との互換性が必要
 */