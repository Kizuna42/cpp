/*
 * ====================================================================
 * CPP01 ex03: ポインタ vs 参照の設計判断 - 比較解説版
 * ====================================================================
 * 
 * この演習では、C++の最重要概念の一つ「ポインタ vs 参照」を学習します。
 * 
 * 【学習目標】
 * - ポインタと参照の根本的な違い
 * - 設計時の判断基準と使い分け
 * - NULL可能性の設計への影響
 * - コンストラクタでの初期化戦略
 * - 実用的な設計パターンの理解
 * 
 * HumanA（参照使用）vs HumanB（ポインタ使用）の比較により、
 * 2つのアプローチの長所・短所を完全理解します。
 */

#ifndef POINTER_VS_REFERENCE_TUTORIAL_HPP
#define POINTER_VS_REFERENCE_TUTORIAL_HPP

#include "Weapon.hpp"

/*
 * ====================================================================
 * 設計の対比: HumanA vs HumanB
 * ====================================================================
 * 
 * 【比較表】
 * 
 *                HumanA              HumanB
 * 武器の保持     Weapon&             Weapon*
 * 初期化         コンストラクタ      setWeapon()
 * NULL可能       不可能              可能
 * 武器変更       不可能              可能
 * メモリ安全性   高い                中程度
 * 使用場面       必須武器            オプション武器
 * 
 * この対比により、C++設計の重要な判断基準を学習します。
 */

/*
 * ====================================================================
 * HumanA クラス - 参照による設計
 * ====================================================================
 * 
 * class HumanA {
 * private:
 *     std::string _name;
 *     Weapon& _weapon;    // ← 参照で保持
 * 
 * 【参照設計の特徴】
 * 
 * 1. 必須関係性
 *    - HumanA は必ず武器を持つ
 *    - 武器なしの HumanA は存在しない
 *    - 強い関連性をコードで表現
 * 
 * 2. 初期化必須
 *    - 参照は宣言と同時に初期化が必要
 *    - コンストラクタで必ず武器を受け取る
 *    - デフォルトコンストラクタは作成不可
 * 
 * 3. 変更不可
 *    - 参照は一度初期化すると変更不可
 *    - 武器の交換はできない
 *    - 不変性による安全性
 * 
 * 4. NULL安全
 *    - 参照は NULL になることがない
 *    - attack() で NULL チェック不要
 *    - より安全で高速なコード
 */

/*
 * ====================================================================
 * HumanB クラス - ポインタによる設計  
 * ====================================================================
 * 
 * class HumanB {
 * private:
 *     std::string _name;
 *     Weapon* _weapon;    // ← ポインタで保持
 * 
 * 【ポインタ設計の特徴】
 * 
 * 1. オプション関係性
 *    - HumanB は武器を持つことも持たないことも可能
 *    - 柔軟な状態管理
 *    - 動的な関係性変更
 * 
 * 2. 遅延初期化
 *    - 武器なしで作成可能
 *    - 後から setWeapon() で設定
 *    - より柔軟な初期化タイミング
 * 
 * 3. 変更可能
 *    - ポインタは何度でも変更可能
 *    - 武器の交換が可能
 *    - 動的な行動変更
 * 
 * 4. NULL対応必要
 *    - ポインタは NULL の可能性
 *    - attack() で NULL チェック必須
 *    - エラーハンドリングの複雑さ
 */

/*
 * ====================================================================
 * 実装比較: コンストラクタの違い
 * ====================================================================
 */

/*
 * HumanA のコンストラクタ:
 * HumanA(std::string name, Weapon& weapon);
 * 
 * 【参照コンストラクタの特徴】
 * 
 * - 武器パラメータが必須
 * - 参照なので NULL 不可
 * - 初期化リストで _weapon(weapon) 必須
 * - 作成時点で完全に初期化される
 * 
 * 使用例:
 * Weapon sword("Excalibur");
 * HumanA arthur("Arthur", sword);  // 必ず武器付きで作成
 */

/*
 * HumanB のコンストラクタ:
 * HumanB(std::string name);
 * 
 * 【ポインタコンストラクタの特徴】
 * 
 * - 武器パラメータは不要
 * - _weapon を NULL で初期化
 * - より簡潔なコンストラクタ
 * - 段階的な初期化が可能
 * 
 * 使用例:
 * HumanB bob("Bob");          // 武器なしで作成
 * bob.setWeapon(some_weapon); // 後から武器設定
 */

/*
 * ====================================================================
 * 実装比較: 攻撃メソッドの違い
 * ====================================================================
 */

/*
 * HumanA の attack():
 * void attack(void) const {
 *     std::cout << _name << " attacks with their " 
 *               << _weapon.getType() << std::endl;
 * }
 * 
 * 【参照攻撃の特徴】
 * 
 * - NULL チェック不要
 * - シンプルで直接的
 * - 高速（条件分岐なし）
 * - 安全性が保証される
 */

/*
 * HumanB の attack():
 * void attack(void) const {
 *     if (_weapon) {
 *         std::cout << _name << " attacks with their " 
 *                   << _weapon->getType() << std::endl;
 *     } else {
 *         std::cout << _name << " has no weapon!" << std::endl;
 *     }
 * }
 * 
 * 【ポインタ攻撃の特徴】
 * 
 * - NULL チェック必須
 * - 条件分岐によるロジック
 * - エラー状態の適切な処理
 * - より複雑だが柔軟
 */

/*
 * ====================================================================
 * 使い分けの判断基準
 * ====================================================================
 * 
 * 【参照を選ぶべき場合】
 * 
 * 1. 必須の関係性
 *    - オブジェクトが必ずその要素を持つ
 *    - 例: Car は必ず Engine を持つ
 * 
 * 2. 不変の関係性
 *    - 一度設定したら変更しない
 *    - 例: Person の birthDate
 * 
 * 3. 高速性重視
 *    - NULL チェックのオーバーヘッドを避けたい
 *    - 例: ゲームの描画処理
 * 
 * 4. 簡潔性重視
 *    - シンプルなコードを保ちたい
 *    - 例: 数学ライブラリの計算関数
 * 
 * 【ポインタを選ぶべき場合】
 * 
 * 1. オプションの関係性
 *    - オブジェクトがその要素を持たない場合がある
 *    - 例: Person の spouse（配偶者）
 * 
 * 2. 動的な関係性
 *    - 実行時に関係性が変わる
 *    - 例: Player の currentWeapon
 * 
 * 3. 遅延初期化
 *    - 作成時には不明、後で設定
 *    - 例: ネットワーク接続の socket
 * 
 * 4. 所有権の移転
 *    - オブジェクトの所有権を移す
 *    - 例: ファクトリー関数の戻り値
 */

/*
 * ====================================================================
 * パフォーマンス比較
 * ====================================================================
 * 
 * 【メモリ使用量】
 * - 参照: ポインタと同じサイズ（通常8バイト）
 * - ポインタ: アドレスサイズ（通常8バイト）
 * → メモリ使用量は同じ
 * 
 * 【実行速度】
 * - 参照: 直接アクセス、NULL チェックなし
 * - ポインタ: 間接アクセス、NULL チェックあり
 * → 参照が微妙に高速
 * 
 * 【コード生成】
 * - 参照: コンパイラ最適化により直接アクセスに変換される場合がある
 * - ポインタ: 必ず間接アクセス
 * → 参照の方が最適化されやすい
 */

/*
 * ====================================================================
 * 実用的な設計例
 * ====================================================================
 * 
 * 【ゲーム開発での応用】
 * 
 * // 必須武器を持つ戦士クラス（参照使用）
 * class Warrior {
 *     std::string name;
 *     Weapon& primaryWeapon;    // 必ず持つ主武器
 * public:
 *     Warrior(const std::string& n, Weapon& w) : name(n), primaryWeapon(w) {}
 *     void attack() const { /* NULL チェック不要 */ }
 * };
 * 
 * // 武器を交換できる冒険者クラス（ポインタ使用）
 * class Adventurer {
 *     std::string name;
 *     Weapon* currentWeapon;    // 武器交換可能
 * public:
 *     Adventurer(const std::string& n) : name(n), currentWeapon(nullptr) {}
 *     void equipWeapon(Weapon* w) { currentWeapon = w; }
 *     void attack() const {
 *         if (currentWeapon) { /* 武器使用 */ }
 *         else { /* 素手攻撃 */ }
 *     }
 * };
 * 
 * 【GUI 開発での応用】
 * 
 * // 必ず親を持つウィジェット（参照使用）
 * class Widget {
 *     Window& parentWindow;     // 必ず親ウィンドウを持つ
 * public:
 *     Widget(Window& parent) : parentWindow(parent) {}
 *     void redraw() const { /* 親ウィンドウのコンテキストを直接使用 */ }
 * };
 * 
 * // オプションでフォーカスを持つコントロール（ポインタ使用）
 * class Control {
 *     Widget* focusedChild;     // フォーカスされた子要素（オプション）
 * public:
 *     Control() : focusedChild(nullptr) {}
 *     void setFocus(Widget* widget) { focusedChild = widget; }
 *     void handleKeyEvent() {
 *         if (focusedChild) { /* フォーカス要素に転送 */ }
 *         else { /* 自分で処理 */ }
 *     }
 * };
 */

/*
 * ====================================================================
 * よくある間違いと解決法
 * ====================================================================
 * 
 * 【間違い1: 参照の再代入を試みる】
 * 
 * ❌ 間違ったコード:
 * class HumanA {
 *     Weapon& _weapon;
 * public:
 *     void changeWeapon(Weapon& newWeapon) {
 *         _weapon = newWeapon;  // エラー！参照の再代入はできない
 *     }
 * };
 * 
 * ✅ 正しい設計:
 * 参照は変更不可が前提。変更が必要ならポインタを使用。
 * 
 * 【間違い2: ポインタの NULL チェック忘れ】
 * 
 * ❌ 危険なコード:
 * void HumanB::attack() const {
 *     std::cout << _weapon->getType();  // NULL の場合クラッシュ！
 * }
 * 
 * ✅ 安全なコード:
 * void HumanB::attack() const {
 *     if (_weapon) {
 *         std::cout << _weapon->getType();
 *     }
 * }
 * 
 * 【間違い3: 参照のデフォルトコンストラクタ】
 * 
 * ❌ コンパイルエラー:
 * class HumanA {
 *     Weapon& _weapon;
 * public:
 *     HumanA() {}  // エラー！参照の初期化が必要
 * };
 * 
 * ✅ 正しい実装:
 * 参照メンバがある場合、必ず初期化リストで初期化。
 */

/*
 * ====================================================================
 * 学習のポイント
 * ====================================================================
 * 
 * 【このファイルから学ぶべきこと】
 * 
 * 1. 設計判断の基準
 *    - 必須 vs オプションの関係性
 *    - 不変 vs 可変の要件
 *    - 安全性 vs 柔軟性のトレードオフ
 * 
 * 2. 実装の違いと影響
 *    - コンストラクタの設計への影響
 *    - メソッド実装の複雑さの違い
 *    - エラーハンドリングの必要性
 * 
 * 3. パフォーマンス考慮
 *    - NULL チェックのコスト
 *    - コンパイラ最適化の違い
 *    - メモリアクセスパターン
 * 
 * 4. 実用的な応用
 *    - ゲーム開発での使い分け
 *    - GUI 開発での応用
 *    - ライブラリ設計での判断
 * 
 * 【マスターすべきスキル】
 * - 要件から適切な選択ができる
 * - それぞれの利点・欠点を説明できる
 * - 実装の違いを正確に書ける
 * - デバッグ時に問題を特定できる
 */

#endif

/*
 * ====================================================================
 * 発展学習のための追加トピック
 * ====================================================================
 * 
 * 【C++11 以降の改善】
 * 
 * スマートポインタの活用:
 * class HumanC {
 *     std::unique_ptr<Weapon> _weapon;  // 自動メモリ管理
 * public:
 *     void setWeapon(std::unique_ptr<Weapon> w) {
 *         _weapon = std::move(w);
 *     }
 * };
 * 
 * std::optional の使用:
 * class HumanD {
 *     std::optional<std::reference_wrapper<Weapon>> _weapon;
 * public:
 *     void setWeapon(Weapon& w) {
 *         _weapon = std::ref(w);
 *     }
 * };
 * 
 * 【関数型プログラミングとの融合】
 * 
 * Maybe モナドパターン:
 * template<typename T>
 * class Maybe {
 *     T* value;
 * public:
 *     template<typename F>
 *     auto map(F f) -> Maybe<decltype(f(*value))> {
 *         if (value) return Maybe(f(*value));
 *         else return Maybe<decltype(f(*value))>();
 *     }
 * };
 * 
 * これらの発展的な内容は、基本的な
 * ポインタ vs 参照を完全理解してから学習する
 */