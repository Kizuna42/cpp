/*
 * ====================================================================
 * CPP01 ex03: Unnecessary violence - Weapon クラスヘッダー解説版
 * ====================================================================
 * 
 * 【学習目標】
 * - 単純だが重要な共有オブジェクトの設計
 * - const correctnessの実践
 * - 参照戻り値の適切な使用
 * - カプセル化の基本実装
 * - 共有リソースとしてのクラス設計
 * 
 * 【重要概念】
 * - Weaponは複数のHumanが共有する可能性
 * - const関数とnon-const関数の使い分け
 * - getter/setterパターンの実装
 * - 参照戻り値によるパフォーマンス最適化
 */

#ifndef WEAPON_HPP
#define WEAPON_HPP

// 【解説】必要なライブラリのインクルード
#include <string>     // std::string クラスを使用するため
#include <iostream>   // デバッグ用出力（必要に応じて）

/*
 * ====================================================================
 * Weaponクラス設計解説
 * ====================================================================
 * 
 * 【設計の基本方針】
 * 
 * 1. シンプルな状態管理
 *    - 武器の種類（type）のみを管理
 *    - 複雑な状態を持たない軽量設計
 * 
 * 2. 共有可能な設計
 *    - 複数のHumanが同じWeaponを参照可能
 *    - 一つのWeaponの変更が全参照者に影響
 * 
 * 3. const correctness
 *    - 読み取り専用操作はconst関数として定義
 *    - 変更操作は非const関数として明確化
 * 
 * 【ex03での役割】
 * このクラスはHumanA/HumanBが使用する共有リソース：
 * - HumanAは参照（&）でWeaponを保持
 * - HumanBはポインタ（*）でWeaponを保持
 * - 両者の違いを明確に示すための基盤クラス
 */
class Weapon {
private:
    /*
     * 【メンバ変数】
     * std::string _type;
     * 
     * 武器の種類を表す文字列：
     * - "crude spiked club"（粗末なとげ付きこん棒）
     * - "some other type of club"（別の種類のこん棒）
     * - "upgraded battle axe"（アップグレードされた戦斧）
     * - など、動的に変更可能
     * 
     * 【設計判断】なぜstd::stringなのか？
     * 
     * 利点：
     * - 可変長文字列（武器名の長さに制限なし）
     * - 動的変更可能（setType()で変更）
     * - メモリ管理自動（std::stringが管理）
     * - 比較演算子が豊富（==, !=, <, > など）
     * 
     * 代替案との比較：
     * - const char*: 変更が困難、メモリ管理が必要
     * - char[]: 固定長、サイズ制限あり
     * - enum: 事前定義が必要、柔軟性低い
     * 
     * 【カプセル化の重要性】
     * privateにする理由：
     * - 直接アクセスを防ぐ（_type = "invalid" などの無効設定）
     * - 将来の拡張に対応（検証ロジックの追加など）
     * - インターフェースの明確化（getter/setterで統一）
     */
    std::string _type;

public:
    /*
     * ====================================================================
     * コンストラクタの解説
     * ====================================================================
     */
    
    /*
     * 【引数付きコンストラクタ】
     * Weapon(std::string type);
     * 
     * 武器作成時に必ず種類を指定する設計：
     * 
     * 設計判断の理由：
     * 1. 意味のある初期化
     *    - 「種類不明の武器」は現実的でない
     *    - 作成時に必ず有効な種類を設定
     * 
     * 2. デフォルトコンストラクタの非提供
     *    - Weapon(); は提供しない
     *    - 未初期化状態を防ぐ
     *    - 明示的な初期化を強制
     * 
     * 期待される使用例：
     * ```cpp
     * Weapon sword("steel sword");     // 正常
     * Weapon club("wooden club");      // 正常
     * Weapon unknown;                  // コンパイルエラー（意図的）
     * ```
     * 
     * 実装の期待動作：
     * ```cpp
     * Weapon::Weapon(std::string type) : _type(type) {
     *     // 初期化リストでtype→_typeに設定
     *     // 必要に応じてログ出力
     * }
     * ```
     */
    Weapon(std::string type);
    
    /*
     * 【デストラクタ】
     * ~Weapon(void);
     * 
     * シンプルなクラスのデストラクタ：
     * 
     * 必要性：
     * - std::string _type は自動的に破棄される
     * - 動的メモリ確保はなし
     * - 主にログ出力やデバッグ用
     * 
     * 設計上の意味：
     * - オブジェクトの生存期間を明確化
     * - RAII原則の遵守
     * - 将来の拡張への備え（ファイルハンドル等）
     * 
     * 実装の期待動作：
     * ```cpp
     * Weapon::~Weapon() {
     *     // 主にデバッグ用のログ出力
     *     // std::string _type の自動破棄
     * }
     * ```
     */
    ~Weapon(void);
    
    /*
     * ====================================================================
     * getter関数の解説
     * ====================================================================
     */
    
    /*
     * 【getType関数】
     * const std::string& getType(void) const;
     * 
     * 武器の種類を取得する関数：
     * 
     * 戻り値の設計: const std::string&
     * 
     * なぜconst参照なのか？
     * 
     * 1. パフォーマンス最適化
     *    - 値渡し: std::stringのコピーが発生（遅い）
     *    - const参照: コピー不要（高速）
     * 
     * 2. 安全性確保
     *    - const: 呼び出し元で値を変更不可
     *    - 参照: 元のオブジェクトへの直接アクセス
     * 
     * 3. メモリ効率
     *    - 追加のメモリ消費なし
     *    - 大きな文字列でも効率的
     * 
     * 関数の設計: const関数
     * 
     * なぜconst関数なのか？
     * 
     * 1. 意図の明確化
     *    - この関数はオブジェクトの状態を変更しない
     *    - コンパイラが状態変更を禁止
     * 
     * 2. constオブジェクトからの呼び出し可能
     *    - const Weapon weapon("sword");
     *    - weapon.getType(); // const関数なので呼び出し可能
     * 
     * 3. コンパイル時チェック
     *    - 意図しない状態変更をコンパイラが検出
     *    - バグの早期発見
     * 
     * 使用例：
     * ```cpp
     * Weapon sword("steel sword");
     * const std::string& type = sword.getType();
     * std::cout << "Weapon type: " << type << std::endl;
     * 
     * // type = "modified"; // コンパイルエラー（const参照）
     * ```
     * 
     * 実装の期待動作：
     * ```cpp
     * const std::string& Weapon::getType() const {
     *     return this->_type;  // const参照で_typeを返す
     * }
     * ```
     */
    const std::string& getType(void) const;
    
    /*
     * ====================================================================
     * setter関数の解説
     * ====================================================================
     */
    
    /*
     * 【setType関数】
     * void setType(std::string type);
     * 
     * 武器の種類を変更する関数：
     * 
     * 引数の設計: std::string type（値渡し）
     * 
     * なぜ値渡しなのか？
     * 
     * 1. 安全性重視
     *    - 呼び出し元の値が変更されない
     *    - コピーされるため独立性確保
     * 
     * 2. シンプルさ重視
     *    - const std::string& より理解しやすい
     *    - 学習段階では値渡しが推奨
     * 
     * 戻り値の設計: void
     * 
     * なぜvoidなのか？
     * 
     * 1. 単一責任原則
     *    - 設定のみに専念
     *    - 戻り値で複雑化しない
     * 
     * 2. エラーハンドリングの簡素化
     *    - 現段階では常に成功
     *    - 将来的に例外処理を追加可能
     * 
     * 関数の設計: 非const関数
     * 
     * なぜ非constなのか？
     * 
     * 1. 状態変更を伴う
     *    - _type の値を変更する
     *    - constでは変更不可
     * 
     * 2. 意図の明確化
     *    - この関数はオブジェクトを変更する
     *    - getType()との明確な区別
     * 
     * 【重要】HumanA/HumanBへの影響
     * 
     * この関数の呼び出しによる影響：
     * - HumanAが参照で保持している場合: 即座に影響
     * - HumanBがポインタで保持している場合: 即座に影響
     * - 同じWeaponを共有している全オブジェクトに影響
     * 
     * 使用例：
     * ```cpp
     * Weapon club("crude spiked club");
     * HumanA bob("Bob", club);
     * 
     * bob.attack();  // "crude spiked club" で攻撃
     * 
     * club.setType("upgraded club");
     * bob.attack();  // "upgraded club" で攻撃（自動更新）
     * ```
     * 
     * 実装の期待動作：
     * ```cpp
     * void Weapon::setType(std::string type) {
     *     this->_type = type;  // 新しい型で置き換え
     * }
     * ```
     */
    void setType(std::string type);
};

#endif

/*
 * ====================================================================
 * 学習確認チェックリスト
 * ====================================================================
 * 
 * Weaponクラスについて理解すべき項目：
 * 
 * □ カプセル化の基本（private変数、public関数）
 * □ const correctness（const関数の意味と重要性）
 * □ 参照戻り値の利点（const std::string&）
 * □ getter/setterパターンの実装
 * □ 共有オブジェクトとしての責任
 * □ 初期化時の値設定の重要性
 * □ デフォルトコンストラクタを提供しない理由
 * □ シンプルなクラス設計の原則
 * 
 * 【実習課題】
 * 1. const関数とnon-const関数の違いを確認
 * 2. 参照戻り値と値戻り値のパフォーマンス比較
 * 3. 複数のHumanが同じWeaponを共有する例を作成
 * 4. setTypeの呼び出しが全参照者に影響することを確認
 */

/*
 * ====================================================================
 * よくある間違いと対策
 * ====================================================================
 * 
 * 【間違い1】const関数でない getter
 * ```cpp
 * std::string& getType();  // non-const関数
 * ```
 * 問題：constオブジェクトから呼び出せない
 * 対策：const関数として定義
 * 
 * 【間違い2】値戻り値のgetter
 * ```cpp
 * std::string getType() const;  // 値戻り値
 * ```
 * 問題：不要なコピーが発生
 * 対策：const参照戻り値を使用
 * 
 * 【間違い3】デフォルトコンストラクタの提供
 * ```cpp
 * Weapon();  // デフォルトコンストラクタ
 * ```
 * 問題：未初期化状態のオブジェクト作成可能
 * 対策：引数付きコンストラクタのみ提供
 * 
 * 【間違い4】setTypeでの検証不足
 * ```cpp
 * void setType(std::string type) {
 *     _type = type;  // 空文字列も受け入れる
 * }
 * ```
 * 問題：無効な武器種類を設定可能
 * 対策：必要に応じて検証ロジックを追加
 */

/*
 * ====================================================================
 * 設計パターンの応用
 * ====================================================================
 * 
 * 【Weaponクラスの設計パターン】
 * 
 * 1. Value Object パターン
 *    - 値を表現するオブジェクト
 *    - 状態の変更可能だが単純
 *    - 比較やコピーが重要
 * 
 * 2. Encapsulation パターン
 *    - データ隠蔽とアクセス制御
 *    - getter/setterによるインターフェース
 *    - 内部実装の変更に柔軟
 * 
 * 3. Shared Resource パターン
 *    - 複数のオブジェクトから参照される
 *    - 状態変更が全参照者に影響
 *    - 慎重な設計が必要
 * 
 * 【将来の拡張可能性】
 * 
 * 現在のシンプルな実装から以下への拡張が可能：
 * 
 * 1. 武器の詳細情報
 * ```cpp
 * class Weapon {
 * private:
 *     std::string _type;
 *     int _damage;        // ダメージ値
 *     int _durability;    // 耐久度
 *     bool _isMagical;    // 魔法武器フラグ
 * };
 * ```
 * 
 * 2. 武器の種類制限
 * ```cpp
 * enum WeaponType { SWORD, AXE, CLUB, BOW };
 * class Weapon {
 * private:
 *     WeaponType _type;   // enum による制限
 * };
 * ```
 * 
 * 3. 武器の状態管理
 * ```cpp
 * class Weapon {
 * private:
 *     std::string _type;
 * public:
 *     bool isUsable() const;      // 使用可能か
 *     void repair();              // 修理
 *     void upgrade(std::string);  // アップグレード
 * };
 * ```
 */

/*
 * ====================================================================
 * ex03全体での位置づけ
 * ====================================================================
 * 
 * 【Weaponクラスの役割】
 * 
 * このクラスはex03の核となる共有リソース：
 * 
 * 1. HumanAとの関係
 *    - 参照（Weapon&）で保持される
 *    - 常に有効な武器を保証
 *    - コンストラクタで初期化必須
 * 
 * 2. HumanBとの関係
 *    - ポインタ（Weapon*）で保持される
 *    - NULLの可能性あり（武器なし状態）
 *    - setWeapon()で後から設定
 * 
 * 3. 設計の対比効果
 *    - 同じWeaponを異なる方法で使用
 *    - 参照とポインタの違いを明確化
 *    - 実用的な設計判断の学習
 * 
 * 【学習効果】
 * 
 * このシンプルなクラスを通じて学習する内容：
 * - 基本的なクラス設計原則
 * - const correctnessの重要性
 * - 共有リソースの管理方法
 * - getter/setterの適切な実装
 * - 参照とポインタの使い分け基準
 */